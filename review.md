# Code Review: psqldef Generic Parser Changes

## 1. Logic Flaws (CRITICAL)

### ⚠️ CRITICAL: Parser Mode Confusion and Circular Fallback Risk

**File**: `database/postgres/parser.go:79-87`

The comment says "Auto mode" tries generic first, then falls back to pgquery:
```go
// Default mode (Auto): try generic parser first, fallback to pgquery with warnings
statements, err := p.parser.Parse(sql)
if err != nil {
    slog.Warn("Generic parser failed, falling back to pgquery (unexpected behavior)", ...)
    return p.parsePgquery(sql)
}
```

But `parsePgquery` (line 117-119) **also** falls back to the generic parser:
```go
if p.mode == PsqldefParserModeAuto {
    slog.Warn("pgquery parseStmt failed, falling back to generic parser for statement", ...)
    stmts, err = p.parser.Parse(ddl)
}
```

**Problems**:
1. **Confusing flow**: Auto mode → generic → (fails) → pgquery → (splits) → parseStmt → (fails) → generic again
2. **The warning says "unexpected behavior"**: If this is truly unexpected, why implement a fallback? This suggests uncertainty about when each parser should be used
3. **Potential for confusion during debugging**: Two different parsing paths can produce different results
4. **Poor separation of concerns**: The fallback logic is duplicated and interleaved

**Recommendation**:
- If the generic parser is ready for production, remove the pgquery fallback and fix any remaining issues
- If not, keep pgquery as primary and document the migration plan
- The current approach creates technical debt by maintaining two parser paths

---

### ⚠️ HIGH: Unique Constraint Name Generation Removed

**File**: `database/postgres/parser.go:210-224`

The code previously auto-generated constraint names for UNIQUE constraints:
```diff
-// Generate a constraint name if not provided to match PostgreSQL's behavior
-constraintName := node.Constraint.Conname
-if constraintName == "" && len(indexCols) == 1 {
-    // Generate name similar to PostgreSQL: tablename_columnname_key
-    constraintName = fmt.Sprintf("%s_%s_key", tableName.Name.String(), indexCols[0].Column.String())
-}
```

Now it just uses the constraint name as-is:
```diff
+index := &parser.IndexDefinition{
+    Info: &parser.IndexInfo{
+        Type:   "UNIQUE",
+        Name:   parser.NewColIdent(node.Constraint.Conname),
```

**Problem**: When PostgreSQL creates a UNIQUE constraint without an explicit name, it auto-generates one (e.g., `users_email_key`). If the parser doesn't generate the same name, schema comparison will fail:
- Current schema: `users_email_key` (auto-generated by PostgreSQL)
- Parsed desired schema: `""` (empty name)
- Result: sqldef thinks they're different constraints → tries to drop and recreate

**Recommendation**: Restore the constraint name generation logic, or verify that this is handled elsewhere in the codebase. Check test cases for unnamed UNIQUE constraints.

---

### ⚠️ MEDIUM: Type Name Fallback May Hide Bugs

**File**: `database/postgres/parser.go:682-689`

```go
rawTypeName := p.getRawTypeName(node.TypeCast.TypeName)
typeName := rawTypeName
if typeName == "" {
    // Fallback to normalized type if raw extraction fails
    typeName = columnType.Type
}
```

**Problem**: If `getRawTypeName` fails (returns `""`), the code silently falls back to the normalized type. This could hide bugs in `getRawTypeName` where:
- The function should work but doesn't (e.g., edge case not handled)
- A legitimate error is being masked

**Recommendation**: Log a warning when fallback occurs, or handle the error explicitly. Silent fallbacks make debugging harder.

---

### ⚠️ MEDIUM: Inconsistent ExclusionPair Field Naming

**File**: `parser/node.go:742-745` vs `schema/ast.go:186-189`

The parser AST changed from `Column` to `Expression`:
```go
// parser/node.go
type ExclusionPair struct {
    Expression Expr    // Changed from Column ColIdent
    Operator   string
}
```

But the schema AST still uses `column`:
```go
// schema/ast.go
type ExclusionPair struct {
    column   string   // Should be renamed to expression for clarity
    operator string
}
```

**Problem**: While the code works (it converts Expression to string and stores in `column`), the naming is misleading:
- New contributors will be confused about why it's called `column` when it can be an expression
- Future refactoring might mistakenly treat it as column-only

**Recommendation**: Rename the field from `column` to `expression` in `schema/ast.go` for consistency and clarity.

## 2. Low-Quality Code

### Duplicated Normalization Calls

**File**: `database/postgres/database.go:580, 676`

The same `normalizePostgresTypeCasts` function is called in two places:

1. In `getColumns` (line 580):
```go
normalizedDef := normalizePostgresTypeCasts(*checkDefinition)
col.Check = &columnConstraint{
    definition: normalizedDef,
    name:       *checkName,
}
```

2. In `getTableCheckConstraints` (line 676):
```go
constraintDef = normalizePostgresTypeCasts(constraintDef)
result[constraintName] = constraintDef
```

**Problem**: The same normalization is applied to different data sources, suggesting:
- The normalization should happen at a common layer
- Or the database queries should return consistent formats

**Recommendation**: Consider normalizing at the database layer or creating a dedicated normalization layer for check constraints.

---

### Inconsistent Logging Levels

**File**: `database/postgres/parser.go:52, 83, 118`

Different logging levels for similar situations:

1. Environment variable set → `Debug` (line 52):
```go
slog.Debug("Using generic parser only mode (PSQLDEF_PARSER=generic)")
```

2. Generic parser fails → `Warn` with "unexpected behavior" (line 83):
```go
slog.Warn("Generic parser failed, falling back to pgquery (unexpected behavior)", ...)
```

3. pgquery parseStmt fails → `Warn` (line 118):
```go
slog.Warn("pgquery parseStmt failed, falling back to generic parser for statement", ...)
```

**Problems**:
- If fallback is "unexpected behavior", it should be `Error` or `Warn`, but then why implement it?
- Logging at `Debug` for mode selection but `Warn` for failures creates inconsistent signal-to-noise
- The message "unexpected behavior" in production code is unprofessional

**Recommendation**:
- If fallback is normal: use `Debug` consistently
- If fallback is exceptional: use `Warn` and remove "unexpected behavior" text
- Clarify in comments when each parser should be used

---

### Complex Nested Logic in Parse Method

**File**: `database/postgres/parser.go:64-136`

The `Parse` method has multiple levels of conditional logic with three different modes and two different parsers. The control flow is hard to follow:

```go
func (p PostgresParser) Parse(sql string) ([]database.DDLStatement, error) {
    if p.mode == PsqldefParserModeGeneric {
        return p.parser.Parse(sql)
    }

    if p.mode == PsqldefParserModePgquery {
        return p.parsePgquery(sql)
    }

    // Auto mode
    statements, err := p.parser.Parse(sql)
    if err != nil {
        return p.parsePgquery(sql)
    }

    return statements, nil
}

func (p PostgresParser) parsePgquery(sql string) ([]database.DDLStatement, error) {
    // ... parsing logic ...
    if err != nil {
        if p.mode == PsqldefParserModeAuto {
            stmts, err = p.parser.Parse(ddl)
        }
        // ...
    }
    // ...
}
```

**Recommendation**: Extract the fallback logic into a separate method, add flow diagram in comments, or simplify by removing one of the parsers.

---

### Poor Variable Naming

**File**: `database/postgres/parser.go:684`

```go
rawTypeName := p.getRawTypeName(node.TypeCast.TypeName)
typeName := rawTypeName
if typeName == "" {
    typeName = columnType.Type
}
```

Both `rawTypeName` and `typeName` are used, but the distinction between "raw" and "normalized" is unclear. Better names would be:
- `rawTypeName` → `typeNameFromPgquery`
- `typeName` → `finalTypeName`
