# Code Review: psqldef Generic Parser Changes

**Branch**: `gfx/psqldef_generic_parser`
**Reviewed**: 2025-11-04

## Executive Summary

This PR makes `psqldef` use the generic parser by default instead of pgquery, a significant architectural change. While the implementation is largely sound, there are **critical logic flaws**, **code quality issues**, and **duplication** that should be addressed before merging.

---

## 1. Logic Flaws (CRITICAL)

### 1.1 ⚠️ CRITICAL: Regex-Based SQL Manipulation Violates Design Principles

**File**: `database/postgres/database.go:631-648`

The `normalizePostgresTypeCasts` function uses regex to parse and modify SQL strings:

```go
re := regexp.MustCompile(`'([^']+)'::time without time zone`)
sql = re.ReplaceAllString(sql, "time '$1'")
```

**Problems**:
1. **Project guidelines violation**: The project's `CLAUDE.md` explicitly states:
   > "The generic parser builds ASTs, and the generator manipulates the ASTs for normalization and comparison. Do not parse strings with regular expressions"

2. **Fragility with escaped quotes**: The regex `'([^']+)'` does not handle PostgreSQL's escaped quotes correctly:
   - Input: `'can''t'::time without time zone`
   - The regex will fail or produce incorrect results
   - PostgreSQL escapes single quotes by doubling them: `'can''t'` represents the string `can't`

3. **False positives in comments/strings**: The regex could match patterns inside SQL comments or other string contexts

**Recommendation**: Refactor to use AST-based normalization instead of regex. If the generic parser cannot parse these constructs, enhance the parser rather than working around it with string manipulation.

---

### 1.2 ⚠️ CRITICAL: Parser Mode Confusion and Circular Fallback Risk

**File**: `database/postgres/parser.go:79-87`

The comment says "Auto mode" tries generic first, then falls back to pgquery:
```go
// Default mode (Auto): try generic parser first, fallback to pgquery with warnings
statements, err := p.parser.Parse(sql)
if err != nil {
    slog.Warn("Generic parser failed, falling back to pgquery (unexpected behavior)", ...)
    return p.parsePgquery(sql)
}
```

But `parsePgquery` (line 117-119) **also** falls back to the generic parser:
```go
if p.mode == PsqldefParserModeAuto {
    slog.Warn("pgquery parseStmt failed, falling back to generic parser for statement", ...)
    stmts, err = p.parser.Parse(ddl)
}
```

**Problems**:
1. **Confusing flow**: Auto mode → generic → (fails) → pgquery → (splits) → parseStmt → (fails) → generic again
2. **The warning says "unexpected behavior"**: If this is truly unexpected, why implement a fallback? This suggests uncertainty about when each parser should be used
3. **Potential for confusion during debugging**: Two different parsing paths can produce different results
4. **Poor separation of concerns**: The fallback logic is duplicated and interleaved

**Recommendation**:
- If the generic parser is ready for production, remove the pgquery fallback and fix any remaining issues
- If not, keep pgquery as primary and document the migration plan
- The current approach creates technical debt by maintaining two parser paths

---

### 1.3 ⚠️ HIGH: Unique Constraint Name Generation Removed

**File**: `database/postgres/parser.go:210-224`

The code previously auto-generated constraint names for UNIQUE constraints:
```diff
-// Generate a constraint name if not provided to match PostgreSQL's behavior
-constraintName := node.Constraint.Conname
-if constraintName == "" && len(indexCols) == 1 {
-    // Generate name similar to PostgreSQL: tablename_columnname_key
-    constraintName = fmt.Sprintf("%s_%s_key", tableName.Name.String(), indexCols[0].Column.String())
-}
```

Now it just uses the constraint name as-is:
```diff
+index := &parser.IndexDefinition{
+    Info: &parser.IndexInfo{
+        Type:   "UNIQUE",
+        Name:   parser.NewColIdent(node.Constraint.Conname),
```

**Problem**: When PostgreSQL creates a UNIQUE constraint without an explicit name, it auto-generates one (e.g., `users_email_key`). If the parser doesn't generate the same name, schema comparison will fail:
- Current schema: `users_email_key` (auto-generated by PostgreSQL)
- Parsed desired schema: `""` (empty name)
- Result: sqldef thinks they're different constraints → tries to drop and recreate

**Recommendation**: Restore the constraint name generation logic, or verify that this is handled elsewhere in the codebase. Check test cases for unnamed UNIQUE constraints.

---

### 1.4 ⚠️ MEDIUM: Type Name Fallback May Hide Bugs

**File**: `database/postgres/parser.go:682-689`

```go
rawTypeName := p.getRawTypeName(node.TypeCast.TypeName)
typeName := rawTypeName
if typeName == "" {
    // Fallback to normalized type if raw extraction fails
    typeName = columnType.Type
}
```

**Problem**: If `getRawTypeName` fails (returns `""`), the code silently falls back to the normalized type. This could hide bugs in `getRawTypeName` where:
- The function should work but doesn't (e.g., edge case not handled)
- A legitimate error is being masked

**Recommendation**: Log a warning when fallback occurs, or handle the error explicitly. Silent fallbacks make debugging harder.

---

### 1.5 ⚠️ MEDIUM: Inconsistent ExclusionPair Field Naming

**File**: `parser/node.go:742-745` vs `schema/ast.go:186-189`

The parser AST changed from `Column` to `Expression`:
```go
// parser/node.go
type ExclusionPair struct {
    Expression Expr    // Changed from Column ColIdent
    Operator   string
}
```

But the schema AST still uses `column`:
```go
// schema/ast.go
type ExclusionPair struct {
    column   string   // Should be renamed to expression for clarity
    operator string
}
```

**Problem**: While the code works (it converts Expression to string and stores in `column`), the naming is misleading:
- New contributors will be confused about why it's called `column` when it can be an expression
- Future refactoring might mistakenly treat it as column-only

**Recommendation**: Rename the field from `column` to `expression` in `schema/ast.go` for consistency and clarity.

---

## 2. Low-Quality Code

### 2.1 String-Based SQL Normalization

**File**: `database/postgres/database.go:631-648`

Already covered in Logic Flaws 1.1. Using regex for SQL manipulation is a code smell in a project that has a full SQL parser.

---

### 2.2 Duplicated Normalization Calls

**File**: `database/postgres/database.go:580, 676`

The same `normalizePostgresTypeCasts` function is called in two places:

1. In `getColumns` (line 580):
```go
normalizedDef := normalizePostgresTypeCasts(*checkDefinition)
col.Check = &columnConstraint{
    definition: normalizedDef,
    name:       *checkName,
}
```

2. In `getTableCheckConstraints` (line 676):
```go
constraintDef = normalizePostgresTypeCasts(constraintDef)
result[constraintName] = constraintDef
```

**Problem**: The same normalization is applied to different data sources, suggesting:
- The normalization should happen at a common layer
- Or the database queries should return consistent formats

**Recommendation**: Consider normalizing at the database layer or creating a dedicated normalization layer for check constraints.

---

### 2.3 Inconsistent Logging Levels

**File**: `database/postgres/parser.go:52, 83, 118`

Different logging levels for similar situations:

1. Environment variable set → `Debug` (line 52):
```go
slog.Debug("Using generic parser only mode (PSQLDEF_PARSER=generic)")
```

2. Generic parser fails → `Warn` with "unexpected behavior" (line 83):
```go
slog.Warn("Generic parser failed, falling back to pgquery (unexpected behavior)", ...)
```

3. pgquery parseStmt fails → `Warn` (line 118):
```go
slog.Warn("pgquery parseStmt failed, falling back to generic parser for statement", ...)
```

**Problems**:
- If fallback is "unexpected behavior", it should be `Error` or `Warn`, but then why implement it?
- Logging at `Debug` for mode selection but `Warn` for failures creates inconsistent signal-to-noise
- The message "unexpected behavior" in production code is unprofessional

**Recommendation**:
- If fallback is normal: use `Debug` consistently
- If fallback is exceptional: use `Warn` and remove "unexpected behavior" text
- Clarify in comments when each parser should be used

---

### 2.4 Complex Nested Logic in Parse Method

**File**: `database/postgres/parser.go:64-136`

The `Parse` method has multiple levels of conditional logic with three different modes and two different parsers. The control flow is hard to follow:

```go
func (p PostgresParser) Parse(sql string) ([]database.DDLStatement, error) {
    if p.mode == PsqldefParserModeGeneric {
        return p.parser.Parse(sql)
    }

    if p.mode == PsqldefParserModePgquery {
        return p.parsePgquery(sql)
    }

    // Auto mode
    statements, err := p.parser.Parse(sql)
    if err != nil {
        return p.parsePgquery(sql)
    }

    return statements, nil
}

func (p PostgresParser) parsePgquery(sql string) ([]database.DDLStatement, error) {
    // ... parsing logic ...
    if err != nil {
        if p.mode == PsqldefParserModeAuto {
            stmts, err = p.parser.Parse(ddl)
        }
        // ...
    }
    // ...
}
```

**Recommendation**: Extract the fallback logic into a separate method, add flow diagram in comments, or simplify by removing one of the parsers.

---

### 2.5 Poor Variable Naming

**File**: `database/postgres/parser.go:684`

```go
rawTypeName := p.getRawTypeName(node.TypeCast.TypeName)
typeName := rawTypeName
if typeName == "" {
    typeName = columnType.Type
}
```

Both `rawTypeName` and `typeName` are used, but the distinction between "raw" and "normalized" is unclear. Better names would be:
- `rawTypeName` → `typeNameFromPgquery`
- `typeName` → `finalTypeName`

---

### 2.6 Test Logging Configuration Smell

**File**: `cmd/testutils/testutils.go:41-55`

The test utility sets up logging configuration in an `init()` function:

```go
func init() {
    util.InitSlog()

    // In test environments, suppress INFO-level logs...
    if os.Getenv("LOG_LEVEL") == "" {
        opts := &slog.HandlerOptions{
            Level: slog.LevelWarn,
        }
        handler := slog.NewTextHandler(os.Stderr, opts)
        slog.SetDefault(slog.New(handler))
    }
}
```

**Problem**: Global state modification in `init()` can cause:
- Test order dependencies
- Hard-to-debug issues when tests fail only in certain orders
- Pollution of global logger state

**Recommendation**: Use test-specific logger configuration or t.Cleanup() to restore state.

---

## 3. Code Duplication

### 3.1 Parser Fallback Logic Duplication

**File**: `database/postgres/parser.go:79-87, 117-119`

The fallback between generic parser and pgquery appears in two places:

1. Top-level `Parse()`: generic → pgquery
2. Within `parsePgquery()`: pgquery's parseStmt → generic

**Recommendation**: Extract fallback logic into a dedicated method like:
```go
func (p PostgresParser) parseWithFallback(sql string, preferGeneric bool) ([]database.DDLStatement, error)
```

---

### 3.2 Test Case Duplication Across Databases

**Files**: `cmd/mysqldef/tests_datatypes.yml`, `cmd/psqldef/tests.yml`, `cmd/mssqldef/tests.yml`

Similar test cases added to multiple files:
- `NegativeDefaultNumbers` (line added: `v11 decimal(10, 4) DEFAULT -0.001`)
- `TypedLiterals`
- `TypedLiteralsIdempotency`
- `TypedLiteralsChangeDefault`

**Problem**: While testing each database is necessary, the structure is duplicated. If the test schema changes, it must be updated in 3+ places.

**Recommendation**: This is acceptable for database-specific tests, but consider:
- Shared test generators for common patterns
- Comments linking related tests across databases
- Or accepting this as necessary duplication for database-specific testing

---

### 3.3 Constraint Name Generation Duplication

**File**: `schema/generator.go:869, 916, 1158`

Constraint name generation appears in multiple places:

```go
// Line 869
constraintName := util.BuildPostgresConstraintName(tableName, desiredColumn.name, "check")

// Line 916
constraintName := util.BuildPostgresConstraintName(tableName, desiredColumn.name, "check")

// Line 1158 (for foreign keys)
constraintName = util.BuildPostgresConstraintName(tableName, columnName, "fkey")
```

**Recommendation**: This is acceptable - the duplication is minimal and the logic is delegated to a utility function. No action needed unless the pattern becomes more complex.

---

## 4. Missing Error Handling

### 4.1 Silent Fallback in Type Name Extraction

**File**: `database/postgres/parser.go:686-689`

Already covered in Logic Flaws 1.4. When `getRawTypeName` returns empty string, the code silently falls back without logging.

---

### 4.2 No Validation of Regex Replacement Results

**File**: `database/postgres/database.go:637-641`

The regex replacements don't validate their results:
```go
re := regexp.MustCompile(`'([^']+)'::time without time zone`)
sql = re.ReplaceAllString(sql, "time '$1'")
```

If the regex fails to compile or produces unexpected results, there's no error checking.

**Recommendation**: Add validation or at least debug logging to show before/after transformation.

---

## 5. Breaking Changes Not Documented

### 5.1 ExclusionPair Structure Change

**File**: `parser/node.go:742-745`

Changed from `Column ColIdent` to `Expression Expr` - this is a breaking change for any code using the parser AST directly.

**Recommendation**: Document in commit message or migration guide.

---

### 5.2 Default Parser Mode Change

The default behavior changed from "pgquery with generic fallback" to "generic with pgquery fallback". This is a major behavioral change.

**Recommendation**: Document in release notes and ensure comprehensive testing.

---

## 6. Positive Observations

Despite the issues above, there are several good practices:

1. **Comprehensive test coverage**: New test cases for TypedLiterals, multi-dimensional arrays, negative defaults
2. **Utility function extraction**: `util.BuildPostgresConstraintName` centralizes constraint naming
3. **Test for generic parser**: `TestPsqldefYamlGenericParser` validates generic parser against all YAML tests
4. **Documentation updates**: `CLAUDE.md` and `AGENTS.md` updated with clear guidelines

---

## 7. Recommendations Summary

### Must Fix (Before Merge)

1. **Replace regex-based normalization** with AST-based approach (1.1)
2. **Clarify parser fallback strategy** and remove "unexpected behavior" warnings (1.2)
3. **Verify UNIQUE constraint name generation** works correctly (1.3)

### Should Fix (Before Merge)

4. Add logging for type name fallback (1.4)
5. Rename `ExclusionPair.column` to `expression` in schema AST (1.5)
6. Make logging levels consistent (2.3)
7. Add error handling for regex replacements (4.2)

### Nice to Have (Future Work)

8. Simplify Parse() method control flow (2.4)
9. Extract fallback logic to reduce duplication (3.1)
10. Add test logging cleanup with t.Cleanup() (2.6)

---

## Conclusion

This PR represents significant work toward making the generic parser production-ready for PostgreSQL. The core implementation is solid, but the **regex-based normalization violates design principles** and the **parser fallback logic is confusing**. These must be addressed before merge.

The test coverage is excellent, and the changes are well-structured overall. With the critical issues fixed, this will be a valuable improvement to the codebase.
