CreateTable:
  desired: |
    CREATE TABLE bigdata (
      data bigint
    );
DropTable:
  current: |
    CREATE TABLE bigdata (
      data bigint
    );
  output: |
    DROP TABLE [dbo].[bigdata];
TestMssqldefColumnLiteral:
  desired: |
    CREATE TABLE v (
      v_integer integer NOT NULL,
      v_text text,
      v_smallmoney smallmoney,
      v_money money,
      v_datetimeoffset datetimeoffset(1),
      v_datetime2 datetime2,
      v_datetime2_with_precision datetime2(3),
      v_smalldatetime smalldatetime,
      v_nchar nchar(30),
      v_nvarchar nvarchar(30),
      v_nvarchar_max nvarchar(max),
      v_varchar_max varchar(max),
      v_varbinary_max varbinary(max),
      v_ntext ntext
    );
TestMssqldefMultipleIndex:
  desired: |
    CREATE TABLE v (
      v_integer integer NOT NULL,
      v_nchar nchar(30)
    );
    CREATE NONCLUSTERED INDEX idx1_v ON v (v_integer);
    CREATE NONCLUSTERED INDEX idx2_v ON v (v_nchar);
CreateIndexWithFilter:
  desired: |
    CREATE TABLE v (
      v_int int
    );
    CREATE INDEX idx_v ON v (v_int) WHERE (v_int IS NOT NULL);
IndexesOnChangedFilter:
  current: |
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
    CREATE INDEX idx_v ON v (v_int, v_nvarchar) WHERE (v_int IS NOT NULL);
  desired: |
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
    CREATE INDEX idx_v ON v (v_int, v_nvarchar) WHERE (v_int IS NOT NULL AND v_nvarchar IS NOT NULL);
  output: |
    DROP INDEX [idx_v] ON [dbo].[v];
    CREATE INDEX idx_v ON v (v_int, v_nvarchar) WHERE (v_int IS NOT NULL AND v_nvarchar IS NOT NULL);

CreateColumnStoreIndex:
  current: |
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
  desired: |
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
    CREATE NONCLUSTERED COLUMNSTORE INDEX idx_v ON v (v_int, v_nvarchar);
  output: |
    CREATE NONCLUSTERED COLUMNSTORE INDEX idx_v ON v (v_int, v_nvarchar);
CreateColumnStoreIndexWithoutKeyword:
  current:
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
  desired: |
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
    CREATE COLUMNSTORE INDEX idx_v ON v (v_int, v_nvarchar);
  output: |
    CREATE COLUMNSTORE INDEX idx_v ON v (v_int, v_nvarchar);
DropColumnStoreIndex:
  current: |
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
    CREATE NONCLUSTERED COLUMNSTORE INDEX idx_v ON v (v_int, v_nvarchar);
  desired: |
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
  output: |
    DROP INDEX [idx_v] ON [dbo].[v];

DropTableOnNonDefaultSchema:
  current: |
    CREATE TABLE FOO.bigdata1 (
      data bigint
    );
    CREATE TABLE FOO.bigdata2 (
      data bigint
    );
  desired: |
    CREATE TABLE FOO.bigdata1 (
      data bigint
    );
  output: |
    DROP TABLE [FOO].[bigdata2];

CreateTableOnNonStandardDefaultSchema:
  desired: |
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
  user: "mssqldef_user"
  
# Built-in types must not be schema-qualified on non-default schema
AddBitColumnOnNonDefaultSchema:
  current: |
    CREATE TABLE items (
      id int
    );
  desired: |
    CREATE TABLE items (
      id int,
      requires_consent bit NOT NULL DEFAULT 1
    );
  output: |
    ALTER TABLE [FOO].[items] ADD [requires_consent] bit NOT NULL DEFAULT 1;
  user: "mssqldef_user"

AddIntColumnOnNonDefaultSchema:
  current: |
    CREATE TABLE items (
      id int
    );
  desired: |
    CREATE TABLE items (
      id int,
      count int NOT NULL
    );
  output: |
    ALTER TABLE [FOO].[items] ADD [count] int NOT NULL;
  user: "mssqldef_user"
DropTableOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE v (
      v_int int,
      v_nvarchar nvarchar(30)
    );
  output: |
    DROP TABLE [FOO].[v];
  user: "mssqldef_user"
MultipleView:
  current: |
    CREATE VIEW v1 AS SELECT 1 AS N;
    CREATE VIEW v2 AS SELECT 2 AS N;
  output: |
    DROP VIEW [dbo].[v1];
    DROP VIEW [dbo].[v2];
UnicodeString:
  desired: |
    CREATE VIEW v AS SELECT Session_Context(N'key') AS x;
InsteadOfTrigger:
  desired: |
    CREATE TABLE users (
      id integer,
      name text,
      age integer,
      CONSTRAINT PK_users PRIMARY KEY CLUSTERED (id)
    );
    CREATE TRIGGER [insert_users] ON [dbo].[users] instead of insert AS
    insert into users(id, name, age) select id + 1, name, age from INSERTED;
ConvertMssqlTypes:
  desired: |
    CREATE VIEW v AS
      SELECT
        Convert(bigint, 0) as v_bigint,
        Convert(bit, 0) as v_bit,
        Convert(int, 2) as v_int,
        Convert(money, 3) as v_money,
        Convert(numeric(9, 3), 4) as v_numeric,
        Convert(smallint, 5) as v_smallint,
        Convert(smallmoney, 6) as v_smallmoney,
        Convert(tinyint, 7) as v_tinyint,
        Convert(float, 8) as v_float,
        Convert(real, 9) as v_real,
        Convert(datetime2(0), '2023-03-11 23:50:00') as v_datetime2,
        Convert(datetimeoffset(0), '2023-03-11 23:50:00+0900') as v_datetimeoffset,
        Convert(smalldatetime, '2023-03-11 23:50') as v_smalldatetime,
        Convert(text, 'Hello, World') as v_text,
        Convert(varchar(20), 'Hello, World') as v_varchar,
        Convert(nchar, N'H') as v_nchar,
        Convert(ntext, N'Hello, World') as v_ntext,
        Convert(nvarchar(20), N'Hello, World') as v_nvarchar,
        Convert(varbinary(20), 123456) as v_varbinary;
SetOptionInTrigger:
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
    CREATE TABLE logs (
      id bigint NOT NULL,
      dt datetime
    );
    CREATE TRIGGER [insert_log] ON [dbo].[users] after insert AS
    set nocount on
    insert into logs select id, getdate() from inserted;
IndexColumnOrder:
  current:
    CREATE TABLE v (
      v1 int,
      v2 int,
      CONSTRAINT [v_pk] PRIMARY KEY CLUSTERED ([v2] ASC, [v1] ASC)
    );
  desired:
    CREATE TABLE v (
      v1 int,
      v2 int,
      CONSTRAINT [v_pk] PRIMARY KEY CLUSTERED ([v2] ASC, [v1] ASC)
    );
  output: ""
ReservedWordColumnName:
  current: |
    CREATE TABLE v(
      [V_INT] int,
      [TIMESTAMP] datetime
    );
  desired: |
    CREATE TABLE v(
      [V_INT] int,
      [TIMESTAMP] datetime
    );
  output: ""
ChangePrimaryKey:
  current: |
    CREATE TABLE v (
      v1 int NOT NULL,
      v2 int NOT NULL,
      CONSTRAINT [v_pk] PRIMARY KEY CLUSTERED ([v1])
    )
  desired: |
    CREATE TABLE v (
      v1 int NOT NULL,
      v2 int NOT NULL,
      CONSTRAINT [v_pk] PRIMARY KEY CLUSTERED ([v2])
    )
  output: |
    ALTER TABLE [dbo].[v] DROP CONSTRAINT [v_pk];
    ALTER TABLE [dbo].[v] ADD CONSTRAINT [v_pk] PRIMARY KEY CLUSTERED ([v2]);
CreateViewWithMultiline:
  desired: |
    CREATE VIEW v AS
    SELECT
    10 as N;
PercentConstraintName:
  current: |
    CREATE TABLE [dbo].[percent_test] (
      [test%] int CONSTRAINT [DF_percent_test_test%] DEFAULT (NULL)
    );
  desired: |
    CREATE TABLE [dbo].[percent_test] (
      [test%] int CONSTRAINT [DF_percent_test_test%] DEFAULT (NULL)
    );
  output: ""
UpdateWithFromAndWhere:
  desired: |
    CREATE TABLE reservation (
      id BIGINT NOT NULL IDENTITY (1, 1),
      start_time DATETIME2(0) NOT NULL,
      end_time DATETIME2(0) NOT NULL,
      reserve_time INTEGER,
      CONSTRAINT reservation_pk PRIMARY KEY CLUSTERED (id)
    );
    CREATE TRIGGER [reservation_insert] ON [dbo].[reservation] instead of update AS
    set nocount on
    update reservation set reserve_time = DATEDIFF(second, inserted.start_time, inserted.end_time) from inserted where reservation.id = inserted.id;
ViewWithHeaderComment:
  desired: |
    -- DUAL view
    CREATE VIEW DUAL AS SELECT 'X' AS X;
  output: |
    CREATE VIEW DUAL AS SELECT 'X' AS X;
TriggerIfWithoutBeginEnd:
  desired: |
    CREATE TABLE users (
        id   int          not null,
        name varchar(255) not null
    );
    CREATE TRIGGER update_name_trigger
        ON users
        AFTER UPDATE
        AS
    IF UPDATE(name)
        BEGIN
            UPDATE u
            SET name = i.name + '+1'
            FROM users AS u
                INNER JOIN inserted AS i ON u.id = i.id
        END
  output: |
    CREATE TABLE users (
        id   int          not null,
        name varchar(255) not null
    );
    CREATE TRIGGER [update_name_trigger] ON [dbo].[users] after update AS
    if UPDATE(name)
    begin
    update u set name = i.name + '+1' from users as u join inserted as i on u.id = i.id
    end;
TriggerIfWithBeginEnd:
  desired: |
    CREATE TABLE users (
        id   int          not null,
        name varchar(255) not null
    );
    CREATE TRIGGER update_name_trigger
        ON users
        AFTER UPDATE
        AS
    BEGIN
        IF UPDATE(name)
            BEGIN
                UPDATE u
                SET name = i.name + '+1'
                FROM users AS u
                    INNER JOIN inserted AS i ON u.id = i.id
            END
    END
  output: |
    CREATE TABLE users (
        id   int          not null,
        name varchar(255) not null
    );
    CREATE TRIGGER [update_name_trigger] ON [dbo].[users] after update AS
    begin
    if UPDATE(name)
    begin
    update u set name = i.name + '+1' from users as u join inserted as i on u.id = i.id
    end
    end;
CollateOnColumn:
  desired: |
    create table users (
        id   int          not null,
        name varchar(255) not null
    );
    create view user_view as
    select id,
          name collate database_default as name
    from users;
DeclareVariable:
  current: |
    CREATE TABLE users (
        id bigint NOT NULL,
        name text
    );
    CREATE TABLE logs (
        id bigint NOT NULL,
        dt datetime
    );
  desired: |
    CREATE TABLE users (
        id bigint NOT NULL,
        name text
    );
    CREATE TABLE logs (
        id bigint NOT NULL,
        dt datetime
    );
    CREATE TRIGGER [insert_log] ON [dbo].[users] after insert AS
    declare @date as datetime
    set nocount on
    begin
        set @date = GETDATE()
        insert into logs select id, @date from inserted
    end
  output: |
    CREATE TRIGGER [insert_log] ON [dbo].[users] after insert AS
    declare
    @date datetime
    set nocount on
    begin
    set @date = getdate()
    insert into logs select id, @date from inserted
    end;
CovertCurrentTimestampWithStyle:
  current: |
    CREATE TABLE users (
        id bigint NOT NULL,
        name text
    );
  desired: |
    CREATE TABLE users (
        id bigint NOT NULL,
        name text
    );
    CREATE TRIGGER [insert_log] ON [dbo].[users] after insert AS
    declare @datetime as datetime
    begin
        set @datetime = CAST(CONVERT(VARCHAR, CURRENT_TIMESTAMP, 110) AS datetime)
    end
  output: |
    CREATE TRIGGER [insert_log] ON [dbo].[users] after insert AS
    declare
    @datetime datetime
    begin
    set @datetime = cast(convert(varchar, current_timestamp, 110) as datetime)
    end;
RenameColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      username text,
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      user_name text, -- @rename from=username
      age integer
    );
  output: |
    EXEC sp_rename 'users.username', 'user_name', 'COLUMN';
RenameColumnWithTypeChange:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      username varchar(100),
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      user_name text NOT NULL, -- @rename from=username
      age integer
    );
  output: |
    EXEC sp_rename 'users.username', 'user_name', 'COLUMN';
    ALTER TABLE [users] ALTER COLUMN [user_name] text NOT NULL;

RenameTable:
  current: |
    CREATE TABLE user_accounts (
      id bigint NOT NULL,
      username text,
      age integer
    );
  desired: |
    CREATE TABLE users ( -- @rename from=user_accounts
      id bigint NOT NULL,
      username text,
      age integer
    );
  output: |
    EXEC sp_rename 'user_accounts', 'users';

RenameTableWithCommentVariant:
  current: |
    CREATE TABLE old_users (
      id bigint NOT NULL,
      name text
    );
  desired: |
    CREATE TABLE new_users /* @rename from=old_users */ (
      id bigint NOT NULL,
      name text
    );
  output: |
    EXEC sp_rename 'old_users', 'new_users';

RenameTableWithQuotedName:
  current: |
    CREATE TABLE [user_accounts] (
      id bigint NOT NULL,
      name text
    );
  desired: |
    CREATE TABLE [user_profiles] ( -- @rename from="user_accounts"
      id bigint NOT NULL,
      name text
    );
  output: |
    EXEC sp_rename 'user_accounts', 'user_profiles';

RenameTableAndMultipleChanges:
  current: |
    CREATE TABLE old_accounts (
      id bigint NOT NULL,
      user_name varchar(50),
      is_active bit,
      old_field text
    );
  desired: |
    CREATE TABLE accounts ( -- @rename from=old_accounts
      id bigint NOT NULL PRIMARY KEY,
      username varchar(100) NOT NULL, -- @rename from=user_name
      is_active bit DEFAULT 1
    );
  output: |
    EXEC sp_rename 'old_accounts', 'accounts';
    EXEC sp_rename 'accounts.user_name', 'username', 'COLUMN';
    ALTER TABLE [accounts] ALTER COLUMN [username] varchar(100) NOT NULL;
    ALTER TABLE [dbo].[accounts] ADD DEFAULT 1 FOR [is_active];
    ALTER TABLE [dbo].[accounts] ADD PRIMARY KEY CLUSTERED ([id]);
    ALTER TABLE [dbo].[accounts] DROP COLUMN [old_field];

RenameIndex:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX old_email_idx ON users (email);
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX new_email_idx /* @rename from=old_email_idx */ ON users (email);
  output: |
    EXEC sp_rename 'users.old_email_idx', 'new_email_idx', 'INDEX';

RenameIndexInTable:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100),
      INDEX idx_email (email)
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100),
      INDEX email_idx (email) -- @rename from=idx_email
    );
  output: |
    EXEC sp_rename 'users.idx_email', 'email_idx', 'INDEX';

RenameMultipleIndexes:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX idx_email ON users (email);
    CREATE INDEX idx_username ON users (username);
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX email_idx /* @rename from=idx_email */ ON users (email);
    CREATE INDEX username_idx /* @rename from=idx_username */ ON users (username);
  output: |
    EXEC sp_rename 'users.idx_email', 'email_idx', 'INDEX';
    EXEC sp_rename 'users.idx_username', 'username_idx', 'INDEX';

RenameUniqueConstraint:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100),
      CONSTRAINT old_unique_email UNIQUE (email)
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100),
      CONSTRAINT unique_email UNIQUE (email) -- @rename from=old_unique_email
    );
  output: |
    EXEC sp_rename 'users.old_unique_email', 'unique_email', 'INDEX';
