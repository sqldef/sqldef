# yaml-language-server: $schema=../../testutil/testcase.schema.json
Comment:
  current: |
    CREATE TABLE "hoge" (
      "id" bigserial NOT NULL,
      "foo" text NOT NULL DEFAULT ''::text,
      PRIMARY KEY ("id")
    );
  desired: |
    CREATE TABLE "hoge" (
        "id" bigserial NOT NULL,
        "foo" text NOT NULL DEFAULT ''::text,
        PRIMARY KEY ("id")
    );

    COMMENT ON TABLE hoge is 'hoge table';
    COMMENT ON COLUMN hoge.id is 'hoge id';
    COMMENT ON COLUMN hoge.foo is 'foo comment';
  up: |
    COMMENT ON TABLE "hoge" IS 'hoge table';
    COMMENT ON COLUMN "hoge"."id" IS 'hoge id';
    COMMENT ON COLUMN "hoge"."foo" IS 'foo comment';
  down: |
    COMMENT ON TABLE "hoge" IS NULL;
    COMMENT ON COLUMN "hoge"."id" IS NULL;
    COMMENT ON COLUMN "hoge"."foo" IS NULL;
MultipleComments:
  current: |
    CREATE TABLE "hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON COLUMN hoge.id is 'hoge id';
  desired: |
    CREATE TABLE "hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON COLUMN hoge.id is 'hoge id';
    COMMENT ON COLUMN bar.id is 'bar id';
  up: |
    COMMENT ON COLUMN "bar"."id" IS 'bar id';
  down: |
    COMMENT ON COLUMN "bar"."id" IS NULL;
UpdateComment:
  current: |
    CREATE TABLE "hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON TABLE hoge is 'hoge table';
    COMMENT ON COLUMN hoge.id is 'hoge id';
    COMMENT ON TABLE bar is 'bar table';
    COMMENT ON COLUMN bar.id is 'bar id';
  desired: |
    CREATE TABLE "hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON TABLE hoge is 'hoge table updated';
    COMMENT ON COLUMN hoge.id is 'hoge id updated';
    COMMENT ON TABLE bar is 'bar table';
    COMMENT ON COLUMN bar.id is 'bar id';
  up: |
    COMMENT ON TABLE "hoge" IS 'hoge table updated';
    COMMENT ON COLUMN "hoge"."id" IS 'hoge id updated';
  down: |
    COMMENT ON TABLE "hoge" IS 'hoge table';
    COMMENT ON COLUMN "hoge"."id" IS 'hoge id';
CommentOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE foo.users (
      id bigint
    );
  desired: |
    CREATE TABLE foo.users (
      id bigint
    );
    COMMENT ON TABLE foo.users is 'users table updated';
    COMMENT ON COLUMN foo.users.id is 'users id';
  up: |
    COMMENT ON TABLE "users" IS 'users table updated';
    COMMENT ON COLUMN "users"."id" IS 'users id';
  down: |
    COMMENT ON TABLE "users" IS NULL;
    COMMENT ON COLUMN "users"."id" IS NULL;
  user: psqldef_user

CommentUnset:
  current: |
    CREATE TABLE users (
      id bigint
    );
    COMMENT ON TABLE users IS 'users table is before update';
    COMMENT ON COLUMN users.id IS 'users id column is before update';
  desired: |
    CREATE TABLE users (
      id bigint
    );
    COMMENT ON TABLE users IS NULL;
    COMMENT ON COLUMN users.id IS null;
  up: |
    COMMENT ON TABLE "users" IS NULL;
    COMMENT ON COLUMN "users"."id" IS NULL;
  down: |
    COMMENT ON TABLE "users" IS 'users table is before update';
    COMMENT ON COLUMN "users"."id" IS 'users id column is before update';
CommentNullWhenAlreadyNull:
  current: |
    CREATE TABLE "status" (
      "id" bigint NOT NULL
    );
  desired: |
    CREATE TABLE "status" (
      "id" bigint NOT NULL
    );
    COMMENT ON COLUMN "status"."id" IS NULL;
CommentWithoutSchema:
  current: |
    CREATE TABLE users (
      id bigint
    );
  desired: |
    CREATE TABLE users (
      id bigint
    );
    COMMENT ON TABLE users is 'users table is updated';
    COMMENT ON COLUMN users.id is 'users id column is updated';
  up: |
    COMMENT ON TABLE "users" IS 'users table is updated';
    COMMENT ON COLUMN "users"."id" IS 'users id column is updated';
  down: |
    COMMENT ON TABLE "users" IS NULL;
    COMMENT ON COLUMN "users"."id" IS NULL;
  user: psqldef_user # in cmd/psqldef/psqldef_test.go schema 'foo' is used if 'user' is provided.
CommentWithoutSchemaWithoutTableNameQuoted:
  current: |
    CREATE TABLE users (
      id bigint,
      "update" boolean
    );
  desired: |
    CREATE TABLE users (
      id bigint,
      "update" boolean
    );
    COMMENT ON TABLE users IS 'users table is updated';
    COMMENT ON COLUMN users.id IS 'users.id column is updated';
    COMMENT ON COLUMN users."update" IS '"users."update" column is updated';
  # Default schema 'public' is needed be prefixed in output to prevent false positive detection of DDL change.
  up: |
    COMMENT ON TABLE "users" IS 'users table is updated';
    COMMENT ON COLUMN "users"."id" IS 'users.id column is updated';
    COMMENT ON COLUMN "users"."update" IS '"users."update" column is updated';
  down: |
    COMMENT ON TABLE "users" IS NULL;
    COMMENT ON COLUMN "users"."id" IS NULL;
    COMMENT ON COLUMN "users"."update" IS NULL;
CommentWithoutSchemaWithTableNameQuoted:
  current: |
    CREATE TABLE "select" (
      id bigint,
      "update" boolean
    );
  desired: |
    CREATE TABLE "select" (
      id bigint,
      "update" boolean
    );
    COMMENT ON TABLE "select" IS '"select" table is updated';
    COMMENT ON COLUMN "select".id IS '"select".id column is updated';
    COMMENT ON COLUMN "select"."update" IS '"select"."update" column is updated';
  # Default schema 'public' is needed be prefixed in output to prevent false positive detection of DDL change.
  up: |
    COMMENT ON TABLE "select" IS '"select" table is updated';
    COMMENT ON COLUMN "select"."id" IS '"select".id column is updated';
    COMMENT ON COLUMN "select"."update" IS '"select"."update" column is updated';
  down: |
    COMMENT ON TABLE "select" IS NULL;
    COMMENT ON COLUMN "select"."id" IS NULL;
    COMMENT ON COLUMN "select"."update" IS NULL;
CommentContainingQuote:
  current: |
    CREATE TABLE test (
      email text
    );
  desired: |
    CREATE TABLE test (
      email text
    );
    COMMENT ON TABLE test is 'World''s best table';
    COMMENT ON COLUMN test.email is 'The user''s contact email address.';
  up: |
    COMMENT ON TABLE "test" IS 'World''s best table';
    COMMENT ON COLUMN "test"."email" IS 'The user''s contact email address.';
  down: |
    COMMENT ON TABLE "test" IS NULL;
    COMMENT ON COLUMN "test"."email" IS NULL;

CommentOnIndex:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE test (id integer);
    CREATE INDEX idx_test ON test (id);
  desired: |
    CREATE TABLE test (id integer);
    CREATE INDEX idx_test ON test (id);
    COMMENT ON INDEX idx_test IS 'Index comment';
  up: |
    COMMENT ON INDEX idx_test IS 'Index comment';
  down: |
    COMMENT ON INDEX idx_test IS NULL;

CommentOnConstraint:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE test (
      id integer,
      CONSTRAINT test_pkey PRIMARY KEY (id)
    );
  desired: |
    CREATE TABLE test (
      id integer,
      CONSTRAINT test_pkey PRIMARY KEY (id)
    );
    COMMENT ON CONSTRAINT test_pkey ON test IS 'Primary key constraint';
  up: |
    COMMENT ON CONSTRAINT test_pkey ON test IS 'Primary key constraint';
  down: |
    COMMENT ON CONSTRAINT test_pkey ON test IS NULL;

CommentOnView:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE test (id integer);
    CREATE VIEW test_view AS SELECT id FROM test;
  desired: |
    CREATE TABLE test (id integer);
    CREATE VIEW test_view AS SELECT id FROM test;
    COMMENT ON VIEW test_view IS 'This is a test view';
  up: |
    COMMENT ON VIEW test_view IS 'This is a test view';
  down: |
    COMMENT ON VIEW test_view IS NULL;

CommentOnFunction:
  legacy_ignore_quotes: false
  current: |
    CREATE FUNCTION test_func() RETURNS void AS $$ BEGIN END; $$ LANGUAGE plpgsql;
  desired: |
    CREATE FUNCTION test_func() RETURNS void AS $$ BEGIN END; $$ LANGUAGE plpgsql;
    COMMENT ON FUNCTION test_func() IS 'This is a test function';
  up: |
    COMMENT ON FUNCTION test_func() IS 'This is a test function';
  down: |
    COMMENT ON FUNCTION test_func() IS NULL;

CommentOnType:
  legacy_ignore_quotes: false
  current: |
    CREATE TYPE status_type AS ENUM ('active', 'inactive');
  desired: |
    CREATE TYPE status_type AS ENUM ('active', 'inactive');
    COMMENT ON TYPE status_type IS 'Status enumeration type';
  up: |
    COMMENT ON TYPE status_type IS 'Status enumeration type';
  down: |
    COMMENT ON TYPE status_type IS NULL;

CommentOnDomain:
  legacy_ignore_quotes: false
  current: |
    CREATE DOMAIN email AS text;
  desired: |
    CREATE DOMAIN email AS text;
    COMMENT ON DOMAIN email IS 'Email address domain';
  up: |
    COMMENT ON DOMAIN email IS 'Email address domain';
  down: |
    COMMENT ON DOMAIN email IS NULL;

CommentOnTrigger:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE test (id integer);
    CREATE FUNCTION trigger_func() RETURNS TRIGGER AS $$ BEGIN RETURN NEW; END; $$ LANGUAGE plpgsql;
    CREATE TRIGGER test_trigger BEFORE INSERT ON test FOR EACH ROW EXECUTE FUNCTION trigger_func();
  desired: |
    CREATE TABLE test (id integer);
    CREATE FUNCTION trigger_func() RETURNS TRIGGER AS $$ BEGIN RETURN NEW; END; $$ LANGUAGE plpgsql;
    CREATE TRIGGER test_trigger BEFORE INSERT ON test FOR EACH ROW EXECUTE FUNCTION trigger_func();
    COMMENT ON TRIGGER test_trigger ON test IS 'Trigger comment';
  up: |
    COMMENT ON TRIGGER test_trigger ON test IS 'Trigger comment';
  down: |
    COMMENT ON TRIGGER test_trigger ON test IS NULL;

# Test constraint name containing a dot (edge case for string splitting)
CommentOnConstraintWithDotInName:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE test (
      id integer,
      CONSTRAINT "my.constraint" CHECK (id > 0)
    );
  desired: |
    CREATE TABLE test (
      id integer,
      CONSTRAINT "my.constraint" CHECK (id > 0)
    );
    COMMENT ON CONSTRAINT "my.constraint" ON test IS 'Constraint with dot in name';
  up: |
    COMMENT ON CONSTRAINT "my.constraint" ON test IS 'Constraint with dot in name';
  down: |
    COMMENT ON CONSTRAINT "my.constraint" ON test IS NULL;

# Test that comments on different object types with the same name are handled correctly.
# This tests the fix for findCommentByObject which must check ObjectType, not just Object name.
CommentOnDifferentObjectTypesWithSameName:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE test (id integer);
    CREATE INDEX foo ON test (id);
    CREATE TYPE foo AS ENUM ('a', 'b');
    COMMENT ON INDEX foo IS 'index comment';
    COMMENT ON TYPE foo IS 'type comment';
  desired: |
    CREATE TABLE test (id integer);
    CREATE INDEX foo ON test (id);
    CREATE TYPE foo AS ENUM ('a', 'b');
    COMMENT ON INDEX foo IS 'index comment';
    COMMENT ON TYPE foo IS 'updated type comment';
  up: |
    COMMENT ON TYPE foo IS 'updated type comment';
  down: |
    COMMENT ON TYPE foo IS 'type comment';

# Test that constraint comments are not cleaned up when the table is dropped.
# PostgreSQL automatically removes constraint comments when the table is dropped.
DropTableWithConstraintComment:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE test (
      id integer,
      CONSTRAINT test_check CHECK (id > 0)
    );
    COMMENT ON CONSTRAINT test_check ON test IS 'Check constraint comment';
  desired: ""
  up: |
    DROP TABLE test;
  down: |
    CREATE TABLE test (
      id integer,
      CONSTRAINT test_check CHECK (id > 0)
    );
    COMMENT ON CONSTRAINT test_check ON test IS 'Check constraint comment';

# Test that index comments are not cleaned up when the table is dropped.
# PostgreSQL automatically removes index comments when the table is dropped.
DropTableWithIndexComment:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE test (id integer);
    CREATE INDEX idx_test ON test (id);
    COMMENT ON INDEX idx_test IS 'Index comment';
  desired: ""
  up: |
    DROP TABLE test;
  down: |
    CREATE TABLE test (id integer);
    CREATE INDEX idx_test ON test (id);
    COMMENT ON INDEX idx_test IS 'Index comment';

# Test that quoted index names are handled correctly when dropping tables.
# "MyIndex" (quoted) and myindex (unquoted) are different indexes in PostgreSQL.
DropTableWithQuotedIndexComment:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE test1 (id integer);
    CREATE INDEX "MyIndex" ON test1 (id);
    COMMENT ON INDEX "MyIndex" IS 'Quoted index comment';
    CREATE TABLE test2 (id integer);
    CREATE INDEX myindex ON test2 (id);
    COMMENT ON INDEX myindex IS 'Unquoted index comment';
  desired: |
    CREATE TABLE test2 (id integer);
    CREATE INDEX myindex ON test2 (id);
    COMMENT ON INDEX myindex IS 'Unquoted index comment';
  up: |
    DROP TABLE test1;
  down: |
    CREATE TABLE test1 (id integer);
    CREATE INDEX "MyIndex" ON test1 (id);
    COMMENT ON INDEX "MyIndex" IS 'Quoted index comment';

# Test that column comments are not cleaned up when the column is dropped.
# PostgreSQL automatically removes column comments when the column is dropped.
DropColumnWithComment:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE hoge (
      id serial PRIMARY KEY,
      foo text,
      bar text,
      baz text
    );
    COMMENT ON COLUMN hoge.foo IS 'foo column';
    COMMENT ON COLUMN hoge.bar IS 'bar column';
    COMMENT ON COLUMN hoge.baz IS 'baz column';
  desired: |
    CREATE TABLE hoge (
      id serial PRIMARY KEY
    );
  up: |
    ALTER TABLE hoge DROP COLUMN baz;
    ALTER TABLE hoge DROP COLUMN bar;
    ALTER TABLE hoge DROP COLUMN foo;
  down: |
    ALTER TABLE hoge ADD COLUMN foo text;
    ALTER TABLE hoge ADD COLUMN bar text;
    ALTER TABLE hoge ADD COLUMN baz text;
    COMMENT ON COLUMN hoge.foo IS 'foo column';
    COMMENT ON COLUMN hoge.bar IS 'bar column';
    COMMENT ON COLUMN hoge.baz IS 'baz column';

# Test that index comments are not cleaned up when the index itself is dropped (not the table).
# PostgreSQL automatically removes index comments when the index is dropped.
DropIndexWithComment:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE hoge (id integer);
    CREATE INDEX idx_hoge ON hoge (id);
    COMMENT ON INDEX idx_hoge IS 'hoge index';
  desired: |
    CREATE TABLE hoge (id integer);
  up: |
    DROP INDEX idx_hoge;
  down: |
    CREATE INDEX idx_hoge ON hoge (id);
    COMMENT ON INDEX idx_hoge IS 'hoge index';

# Test that index comment cleanup only skips dropped indexes, not all indexes.
# Other index comments should still be cleaned up.
DropIndexWithCommentAndKeepOther:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE hoge (
      id integer,
      foo text
    );
    CREATE INDEX idx_hoge_id ON hoge (id);
    CREATE INDEX idx_hoge_foo ON hoge (foo);
    COMMENT ON INDEX idx_hoge_id IS 'id index';
    COMMENT ON INDEX idx_hoge_foo IS 'foo index';
  desired: |
    CREATE TABLE hoge (
      id integer,
      foo text
    );
    CREATE INDEX idx_hoge_id ON hoge (id);
    COMMENT ON INDEX idx_hoge_id IS 'id index';
  up: |
    DROP INDEX idx_hoge_foo;
  down: |
    CREATE INDEX idx_hoge_foo ON hoge (foo);
    COMMENT ON INDEX idx_hoge_foo IS 'foo index';

# Test that column comment cleanup only skips dropped columns, not all columns.
# Other column comments should still be cleaned up.
DropColumnWithCommentAndKeepOther:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE hoge (
      id integer,
      foo text,
      bar text
    );
    COMMENT ON COLUMN hoge.id IS 'id column';
    COMMENT ON COLUMN hoge.foo IS 'foo column';
    COMMENT ON COLUMN hoge.bar IS 'bar column';
  desired: |
    CREATE TABLE hoge (
      id integer,
      bar text
    );
    COMMENT ON COLUMN hoge.id IS 'id column';
  up: |
    ALTER TABLE hoge DROP COLUMN foo;
    COMMENT ON COLUMN hoge.bar IS NULL;
  down: |
    ALTER TABLE hoge ADD COLUMN foo text;
    COMMENT ON COLUMN hoge.foo IS 'foo column';
    COMMENT ON COLUMN hoge.bar IS 'bar column';
