CreateTable:
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
    CREATE TABLE bigdata (
      data bigint
    );
DropTable:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
    CREATE TABLE bigdata (
      data bigint
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  output: |
    DROP TABLE "public"."bigdata";
EmptyTable:
  desired: |
    CREATE TABLE public.test ();
CreateTableWithDefault:
  desired: |
    CREATE TABLE users (
      profile character varying(50) NOT NULL DEFAULT ''::character varying,
      default_int int default 20,
      default_bool bool default true,
      default_numeric numeric(5) default 42.195,
      default_fixed_char character(3) default 'JPN'::bpchar,
      default_text text default ''::text,
      default_json json default '[]'::json,
      default_jsonb jsonb default '[]'::jsonb,
      default_current_timestamp timestamp default CURRENT_TIMESTAMP,
      default_current_date date default CURRENT_DATE,
      default_current_time time default CURRENT_TIME,
      default_date_text text DEFAULT CURRENT_TIMESTAMP::date::text,
      default_now timestamp default now(),
      default_array_int int[] default '{}'::int[],
      default_array_constructor int[] DEFAULT ARRAY[]::int[],
      default_array_element_typecast text[] DEFAULT ARRAY[current_date::text]::text[],
      joined_at timestamp with time zone NOT NULL DEFAULT '0001-01-01 00:00:00'::timestamp without time zone,
      created_at timestamp with time zone DEFAULT now()
    );
CreateTableWithDefaultContainingQuote:
  current: |
    CREATE TABLE test ();
  desired: |
    CREATE TABLE test (
      thing text default 'it''s free real estate'
    );
  output: |
    ALTER TABLE "public"."test" ADD COLUMN "thing" text DEFAULT 'it''s free real estate';
CreateTableChangeDefaultBoolean:
  current: |
    CREATE TABLE test (
      col boolean default true
    );
  desired: |
    CREATE TABLE test (
      col boolean default false
    );
  output: |
    ALTER TABLE "public"."test" ALTER COLUMN "col" SET DEFAULT false;
ParseTextCheckConstraint:
  current: |
    CREATE TABLE test (
      col text NOT NULL CHECK (col <> ''::text)
    );
  desired: |
    CREATE TABLE test (
      col text NOT NULL
    );
  output: |
    ALTER TABLE "public"."test" DROP CONSTRAINT "test_col_check";
CheckConstraintWithReservedWordColumnName:
  desired: |
    CREATE TABLE test (
      "point" integer NOT NULL CONSTRAINT check_point CHECK (point > 0)
    );
DropPrimaryKey:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL PRIMARY KEY,
      name text
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
  output: |
    ALTER TABLE "public"."users" DROP CONSTRAINT "users_pkey";
ParseAllAnyCheckConstraint:
  current: |
    CREATE TABLE test (
      n1 int,
      n2 int,
      t1 text
    );
  desired: |
    CREATE TABLE test (
      n1 int CHECK (n1 = ANY (ARRAY[1, 2, 3])),
      n2 int CHECK (n2 = ALL (ARRAY[1, 2, 3])),
      t1 text CHECK (t1 = SOME (ARRAY['x', 'y']))
    );
  output: |
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_n1_check" CHECK (n1 = ANY (ARRAY[1, 2, 3]));
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_n2_check" CHECK (n2 = ALL (ARRAY[1, 2, 3]));
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_t1_check" CHECK (t1 = ANY (ARRAY['x', 'y']));
AllAnySomeCheckConstraintsCreate:
  desired: |
    CREATE TABLE test_all_any (
      id INTEGER PRIMARY KEY,
      state TEXT CHECK (state = ANY (ARRAY['active', 'pending'])),
      all_positive INTEGER CHECK (all_positive = ALL (ARRAY[1, 2, 3])),
      some_text TEXT CHECK (some_text = SOME (ARRAY['valid', 'allowed'])),
      score INTEGER CHECK (score > ALL (ARRAY[0, 10, 20]))
    );
AllAnySomeCheckConstraintsModifyAll:
  current: |
    CREATE TABLE test_all_any (
      id INTEGER PRIMARY KEY,
      state TEXT CHECK (state = ANY (ARRAY['active', 'pending'])),
      all_positive INTEGER CHECK (all_positive = ALL (ARRAY[1, 2, 3])),
      some_text TEXT CHECK (some_text = SOME (ARRAY['valid', 'allowed'])),
      score INTEGER CHECK (score > ALL (ARRAY[0, 10, 20]))
    );
  desired: |
    CREATE TABLE test_all_any (
      id INTEGER PRIMARY KEY,
      state TEXT CHECK (state = ANY (ARRAY['active', 'pending'])),
      all_positive INTEGER CHECK (all_positive = ALL (ARRAY[2, 3, 4])),
      some_text TEXT CHECK (some_text = SOME (ARRAY['valid', 'allowed'])),
      score INTEGER CHECK (score > ALL (ARRAY[0, 10, 20]))
    );
  output: |
    ALTER TABLE "public"."test_all_any" DROP CONSTRAINT "test_all_any_all_positive_check";
    ALTER TABLE "public"."test_all_any" ADD CONSTRAINT "test_all_any_all_positive_check" CHECK (all_positive = ALL (ARRAY[2, 3, 4]));
AllAnySomeCheckConstraintsModifySome:
  current: |
    CREATE TABLE test_all_any (
      id INTEGER PRIMARY KEY,
      state TEXT CHECK (state = ANY (ARRAY['active', 'pending'])),
      all_positive INTEGER CHECK (all_positive = ALL (ARRAY[2, 3, 4])),
      some_text TEXT CHECK (some_text = SOME (ARRAY['valid', 'allowed'])),
      score INTEGER CHECK (score > ALL (ARRAY[0, 10, 20]))
    );
  desired: |
    CREATE TABLE test_all_any (
      id INTEGER PRIMARY KEY,
      state TEXT CHECK (state = ANY (ARRAY['active', 'pending'])),
      all_positive INTEGER CHECK (all_positive = ALL (ARRAY[2, 3, 4])),
      some_text TEXT CHECK (some_text = SOME (ARRAY['updated', 'modified', 'changed'])),
      score INTEGER CHECK (score > ALL (ARRAY[0, 10, 20]))
    );
  output: |
    ALTER TABLE "public"."test_all_any" DROP CONSTRAINT "test_all_any_some_text_check";
    ALTER TABLE "public"."test_all_any" ADD CONSTRAINT "test_all_any_some_text_check" CHECK (some_text = ANY (ARRAY['updated', 'modified', 'changed']));
AllAnySomeCheckConstraintsRemove:
  current: |
    CREATE TABLE test_all_any (
      id INTEGER PRIMARY KEY,
      state TEXT CHECK (state = ANY (ARRAY['active', 'pending'])),
      all_positive INTEGER CHECK (all_positive = ALL (ARRAY[2, 3, 4])),
      some_text TEXT CHECK (some_text = SOME (ARRAY['updated', 'modified', 'changed'])),
      score INTEGER CHECK (score > ALL (ARRAY[0, 10, 20]))
    );
  desired: |
    CREATE TABLE test_all_any (
      id INTEGER PRIMARY KEY,
      state TEXT,
      all_positive INTEGER,
      some_text TEXT,
      score INTEGER
    );
  output: |
    ALTER TABLE "public"."test_all_any" DROP CONSTRAINT "test_all_any_state_check";
    ALTER TABLE "public"."test_all_any" DROP CONSTRAINT "test_all_any_all_positive_check";
    ALTER TABLE "public"."test_all_any" DROP CONSTRAINT "test_all_any_some_text_check";
    ALTER TABLE "public"."test_all_any" DROP CONSTRAINT "test_all_any_score_check";
SomeConstraintModificationsCreate:
  desired: |
    CREATE TABLE test_some_modify (
      id INTEGER PRIMARY KEY,
      status TEXT CHECK (status = SOME (ARRAY['active', 'pending', 'draft'])),
      category TEXT CHECK (category = SOME (ARRAY['A', 'B', 'C']))
    );
SomeConstraintModificationsModify:
  current: |
    CREATE TABLE test_some_modify (
      id INTEGER PRIMARY KEY,
      status TEXT CHECK (status = SOME (ARRAY['active', 'pending', 'draft'])),
      category TEXT CHECK (category = SOME (ARRAY['A', 'B', 'C']))
    );
  desired: |
    CREATE TABLE test_some_modify (
      id INTEGER PRIMARY KEY,
      status TEXT CHECK (status = SOME (ARRAY['active', 'completed', 'archived'])),
      category TEXT CHECK (category = SOME (ARRAY['X', 'Y', 'Z']))
    );
  output: |
    ALTER TABLE "public"."test_some_modify" DROP CONSTRAINT "test_some_modify_status_check";
    ALTER TABLE "public"."test_some_modify" ADD CONSTRAINT "test_some_modify_status_check" CHECK (status = ANY (ARRAY['active', 'completed', 'archived']));
    ALTER TABLE "public"."test_some_modify" DROP CONSTRAINT "test_some_modify_category_check";
    ALTER TABLE "public"."test_some_modify" ADD CONSTRAINT "test_some_modify_category_check" CHECK (category = ANY (ARRAY['X', 'Y', 'Z']));
SomeConstraintModificationsSomeToAny:
  current: |
    CREATE TABLE test_some_modify (
      id INTEGER PRIMARY KEY,
      status TEXT CHECK (status = SOME (ARRAY['active', 'completed', 'archived'])),
      category TEXT CHECK (category = SOME (ARRAY['X', 'Y', 'Z']))
    );
  desired: |
    CREATE TABLE test_some_modify (
      id INTEGER PRIMARY KEY,
      status TEXT CHECK (status = ANY (ARRAY['active', 'completed', 'archived'])),
      category TEXT CHECK (category = ANY (ARRAY['X', 'Y', 'Z']))
    );
  output: ""
SomeConstraintModificationsSomeToAll:
  current: |
    CREATE TABLE test_some_modify (
      id INTEGER PRIMARY KEY,
      status TEXT CHECK (status = SOME (ARRAY['active', 'completed', 'archived'])),
      category TEXT CHECK (category = SOME (ARRAY['X', 'Y', 'Z']))
    );
  desired: |
    CREATE TABLE test_some_modify (
      id INTEGER PRIMARY KEY,
      status TEXT CHECK (status = ALL (ARRAY['active', 'completed', 'archived'])),
      category TEXT CHECK (category = ALL (ARRAY['X', 'Y', 'Z']))
    );
  output: |
    ALTER TABLE "public"."test_some_modify" DROP CONSTRAINT "test_some_modify_status_check";
    ALTER TABLE "public"."test_some_modify" ADD CONSTRAINT "test_some_modify_status_check" CHECK (status = ALL (ARRAY['active', 'completed', 'archived']));
    ALTER TABLE "public"."test_some_modify" DROP CONSTRAINT "test_some_modify_category_check";
    ALTER TABLE "public"."test_some_modify" ADD CONSTRAINT "test_some_modify_category_check" CHECK (category = ALL (ARRAY['X', 'Y', 'Z']));
NullCast:
  desired: |
    CREATE TABLE public.test (
      "item" character varying(16) DEFAULT NULL
    );
NumericCast:
  desired: |
    CREATE TABLE public.test_table (
      "item" numeric
    );
    CREATE VIEW public.test_view AS SELECT t.item FROM test_table t WHERE (t.item = (0)::numeric);
CreateIndexConcurrently:
  current: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128) DEFAULT 'konsumer'
    );
  desired: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128) DEFAULT 'konsumer'
    );
    CREATE INDEX CONCURRENTLY username on users (name);
  output: |
    CREATE INDEX CONCURRENTLY username on users (name);
CreateIndexWithCoalesce:
  current: |
    CREATE TABLE users (
      name TEXT,
      user_name TEXT
    );
  desired: |
    CREATE TABLE users (
      name TEXT,
      user_name TEXT
    );
    CREATE INDEX create_index_with_function_call ON users (name, COALESCE(user_name, 'NO_NAME'::TEXT));
  output: |
    CREATE INDEX create_index_with_function_call ON users (name, COALESCE(user_name, 'NO_NAME'::TEXT));
CreateIndexWithBoolExpr:
  current: |
    CREATE TABLE users (
      is_active BOOLEAN
    );
  desired: |
    CREATE TABLE users (
      is_active BOOLEAN
    );
    CREATE INDEX create_index_with_bool ON users ((CASE WHEN is_active IS TRUE THEN 1 ELSE 0 END));
  output: |
    CREATE INDEX create_index_with_bool ON users ((CASE WHEN is_active IS TRUE THEN 1 ELSE 0 END));
AlterTypeAddValue:
  current: |
    CREATE TYPE eventtype AS ENUM (
      'example',
      'send_message'
    );

    CREATE TABLE events (
      id UUID NOT NULL PRIMARY KEY,
      event_type eventtype NOT NULL
    );
  desired: |
    CREATE TYPE eventtype AS ENUM (
      'example',
      'send_message',
      'send_meeting_options',
      'update_reactionslot'
    );

    CREATE TABLE events (
      id UUID NOT NULL PRIMARY KEY,
      event_type eventtype NOT NULL
    );
  output: |
    ALTER TYPE "public"."eventtype" ADD VALUE 'send_meeting_options';
    ALTER TYPE "public"."eventtype" ADD VALUE 'update_reactionslot';
  min_version: '12'
AlterTypeAddValueWithSameTypeNameInDifferentSchema:
  current: |
    CREATE SCHEMA schema1;
    CREATE SCHEMA schema2;
    CREATE TYPE schema1.lang AS ENUM (
      'ja',
      'en'
    );
    CREATE TYPE schema2.lang AS ENUM (
      'ja',
      'en'
    );
  desired: |
    CREATE TYPE schema1.lang AS ENUM (
      'ja',
      'en'
    );
    CREATE TYPE schema2.lang AS ENUM (
      'ja',
      'en',
      'de'
    );
  output: |
    ALTER TYPE "schema2"."lang" ADD VALUE 'de';
  min_version: '12'
AddEnumTypeColumn:
  current: |
    CREATE SCHEMA s;
    CREATE TABLE s.users (
      id UUID NOT NULL PRIMARY KEY
    );
  desired: |
    CREATE TYPE s.lang AS ENUM (
      'ja',
      'en'
    );
    CREATE TABLE s.users (
      id UUID NOT NULL PRIMARY KEY,
      lang s.lang NOT NULL
    );
  output: |
    CREATE TYPE s.lang AS ENUM (
      'ja',
      'en'
    );
    ALTER TABLE "s"."users" ADD COLUMN "lang" s.lang NOT NULL;

CreateTypeWithMultipleTables:
  desired: |
    CREATE TYPE order_status AS ENUM ('pending', 'shipped');
    CREATE TABLE customers (
      id SERIAL PRIMARY KEY
    );
    CREATE TABLE orders (
      id SERIAL PRIMARY KEY,
      status order_status NOT NULL
    );

CreateMultipleTypesWithMultipleTables:
  desired: |
    CREATE TYPE order_status AS ENUM ('pending', 'shipped', 'delivered');
    CREATE TYPE payment_method AS ENUM ('credit_card', 'paypal', 'bank_transfer');
    CREATE TABLE customers (
      id SERIAL PRIMARY KEY,
      name TEXT NOT NULL
    );
    CREATE TABLE orders (
      id SERIAL PRIMARY KEY,
      customer_id INTEGER REFERENCES customers(id),
      status order_status NOT NULL,
      payment payment_method NOT NULL
    );

UUIDCast:
  desired: |
    CREATE TABLE public.test_table (
      "id" uuid NOT NULL,
      "tenant_id" uuid NOT NULL,
      PRIMARY KEY ("id", "tenant_id")
    );
    CREATE POLICY tenant_isolation_policy ON test_table AS PERMISSIVE FOR ALL TO public
    USING (current_schema()::uuid = current_database()::uuid);
CreateIndexWithoutName:
  desired: |
    CREATE TABLE "user" (id BIGINT NOT NULL);
    CREATE INDEX ON "user" (id);
TypeColumn:
  desired: |
    CREATE TABLE "public"."test_table" (
      "id" bigint NOT NULL,
      "type" character varying(10)
    );
    CREATE VIEW public.test_view AS SELECT test_table.id, test_table."type" FROM test_table;
PosixRegexCheckConstraint:
  current: |
    CREATE TABLE test (
      posix_regex        text NOT NULL CHECK (posix_regex        ~   '[0-9]'),
      posix_regex_ci     text NOT NULL CHECK (posix_regex_ci     ~*  '[0-9]'),
      posix_not_regex    text NOT NULL CHECK (posix_not_regex    !~  '[0-9]'),
      posix_not_regex_ci text NOT NULL CHECK (posix_not_regex_ci !~* '[0-9]')
    );
  desired: |
    CREATE TABLE test (
      posix_regex        text NOT NULL CHECK (posix_regex        ~   '[a-z]'),
      posix_regex_ci     text NOT NULL CHECK (posix_regex_ci     ~*  '[a-z]'),
      posix_not_regex    text NOT NULL CHECK (posix_not_regex    !~  '[a-z]'),
      posix_not_regex_ci text NOT NULL CHECK (posix_not_regex_ci !~* '[a-z]')
    );
  output: |
    ALTER TABLE "public"."test" DROP CONSTRAINT "test_posix_regex_check";
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_posix_regex_check" CHECK (posix_regex ~ '[a-z]');
    ALTER TABLE "public"."test" DROP CONSTRAINT "test_posix_regex_ci_check";
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_posix_regex_ci_check" CHECK (posix_regex_ci ~* '[a-z]');
    ALTER TABLE "public"."test" DROP CONSTRAINT "test_posix_not_regex_check";
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_posix_not_regex_check" CHECK (posix_not_regex !~ '[a-z]');
    ALTER TABLE "public"."test" DROP CONSTRAINT "test_posix_not_regex_ci_check";
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_posix_not_regex_ci_check" CHECK (posix_not_regex_ci !~* '[a-z]');
IndexAndForeignOrder:
  desired: |
    CREATE TABLE posts (
      id bigint NOT NULL,
      user_id bigint NOT NULL,
      PRIMARY KEY ("id")
    );
    ALTER TABLE posts ADD CONSTRAINT "user_id_key" FOREIGN KEY ("user_id") REFERENCES users ("id");
    CREATE TABLE users (
      id bigint NOT NULL
    );
    CREATE UNIQUE INDEX uniq_idx ON users (id);
  output: |
    CREATE TABLE posts (
      id bigint NOT NULL,
      user_id bigint NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE users (
      id bigint NOT NULL
    );
    CREATE UNIQUE INDEX uniq_idx ON users (id);
    ALTER TABLE posts ADD CONSTRAINT "user_id_key" FOREIGN KEY ("user_id") REFERENCES users ("id");
ForeignKeyConstraintsAreEmittedLast:
  current: |
    CREATE TABLE foos ( dummy_column text );
    CREATE TABLE bars ( dummy_column text );
  desired: |
    CREATE TABLE foos (
      foo_id bigint PRIMARY KEY,
      bar_id bigint NOT NULL REFERENCES bars (bar_id)
    );
    CREATE TABLE bars (
      bar_id bigint PRIMARY KEY
    );
  output: |
    ALTER TABLE "public"."bars" ADD COLUMN "bar_id" bigint NOT NULL;
    ALTER TABLE "public"."bars" ADD PRIMARY KEY ("bar_id");
    ALTER TABLE "public"."foos" ADD COLUMN "foo_id" bigint NOT NULL;
    ALTER TABLE "public"."foos" ADD COLUMN "bar_id" bigint NOT NULL;
    ALTER TABLE "public"."foos" ADD PRIMARY KEY ("foo_id");
    ALTER TABLE "public"."foos" ADD CONSTRAINT "foos_bar_id_fkey" FOREIGN KEY ("bar_id") REFERENCES "public"."bars" ("bar_id");
    ALTER TABLE "public"."bars" DROP COLUMN "dummy_column";
    ALTER TABLE "public"."foos" DROP COLUMN "dummy_column";
ForeignKeyOnReservedName:
  current: |
    CREATE TABLE "public"."companies" (
      "id" character varying(100) NOT NULL,
      PRIMARY KEY ("id")
    );

    CREATE TABLE "public"."variables" (
      "id" character varying(100) NOT NULL,
      "company_id" character varying(100) NOT NULL,
      PRIMARY KEY ("id")
    );

    CREATE TABLE "public"."users" (
      "id" character varying(100) NOT NULL,
      "variable_id" character varying(100) NOT NULL,
      "name" character varying(100),
      PRIMARY KEY ("id")
    );
  desired: |
    CREATE TABLE IF NOT EXISTS companies (
      id VARCHAR(100) PRIMARY KEY
    );

    CREATE TABLE IF NOT EXISTS variables (
      id VARCHAR(100) PRIMARY KEY,
      company_id VARCHAR(100) NOT NULL REFERENCES companies(id)
    );

    CREATE TABLE IF NOT EXISTS users (
      id VARCHAR(100) PRIMARY KEY,
      variable_id VARCHAR(100) NOT NULL,
      name VARCHAR(100),
      CONSTRAINT users_variable_id_fk FOREIGN KEY (variable_id) REFERENCES variables(id)
    );
  output: |
    ALTER TABLE "public"."variables" ADD CONSTRAINT "variables_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies" ("id");
    ALTER TABLE "public"."users" ADD CONSTRAINT "users_variable_id_fk" FOREIGN KEY ("variable_id") REFERENCES "public"."variables" ("id");
NumericChangePrecisionAndScale:
  current: |
    CREATE TABLE test (
      num numeric (10, 3)
    );
  desired: |
    CREATE TABLE test (
      num numeric (10, 2)
    );
  output: |
    ALTER TABLE "public"."test" ALTER COLUMN "num" TYPE numeric(10, 2);
CheckConstraint:
  current: |
    CREATE TABLE test (
      n1 integer,
      n2 integer,
      n3 integer,
      t1 text,
      t2 text,
      t3 text,
      t4 varchar(10),
      d1 date,
      d2 date
    );
  desired: |
    CREATE TABLE test (
      n1 integer CHECK (n1 = 0 or not n1 > 10 and n1 IS NOT NULL),
      n2 integer CONSTRAINT chk CHECK (n2 > 0),
      n3 integer CHECK (n3 > 0) NO INHERIT,
      t1 text CHECK (t1 like 'x'),
      t2 text CHECK (t2 not like 'x'),
      t3 text CHECK (t3 <> ''::text),
      t4 varchar(10) CHECK (t4::text ~ '[0-9]'),
      d1 date CHECK (d1 >= '2022-01-01'::date),
      d2 date CHECK (d2 >= date '2022-01-01')
    );
  output: |
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_n1_check" CHECK (n1 = 0 or not n1 > 10 and n1 is not null);
    ALTER TABLE "public"."test" ADD CONSTRAINT "chk" CHECK (n2 > 0);
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_n3_check" CHECK (n3 > 0) NO INHERIT;
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_t1_check" CHECK (t1 ~~ 'x');
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_t2_check" CHECK (t2 !~~ 'x');
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_t3_check" CHECK (t3 <> '');
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_t4_check" CHECK (t4 ~ '[0-9]');
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_d1_check" CHECK (d1 >= '2022-01-01');
    ALTER TABLE "public"."test" ADD CONSTRAINT "test_d2_check" CHECK (d2 >= '2022-01-01');

CheckConstraintWithRowConstructor:
  desired: |
    CREATE TABLE test (
      a integer,
      b integer,
      CONSTRAINT test_check CHECK ((a, b) > (0, 0))
    );

CompositeForeignKeyConstraint:
  current: |
    CREATE TABLE t1 (
      id1 int not null,
      id2 int not null,
      PRIMARY KEY (id1, id2)
    );
    CREATE TABLE t2 (
      id1 int not null,
      id2 int not null,
      PRIMARY KEY (id1, id2)
    );
  desired: |
    CREATE TABLE t1 (
      id1 int not null,
      id2 int not null,
      PRIMARY KEY (id1, id2)
    );
    CREATE TABLE t2 (
      id1 int not null,
      id2 int not null,
      PRIMARY KEY (id1, id2),
      CONSTRAINT fk FOREIGN KEY (id1, id2) REFERENCES t1 (id1, id2)
    );
  output: |
    ALTER TABLE "public"."t2" ADD CONSTRAINT "fk" FOREIGN KEY ("id1","id2") REFERENCES "public"."t1" ("id1","id2");
IntervalExpression:
  desired: |
    CREATE TABLE points (id bigint, created_at timestamp, main_type text, sub_type text, user_id bigint);
    CREATE MATERIALIZED VIEW IF NOT EXISTS points_view AS
    SELECT * FROM points
    WHERE id IN (
      SELECT MAX(id) AS id
      FROM points
      WHERE to_timestamp(concat(to_char(current_date - INTERVAL '1 YEAR' + INTERVAL '1 DAY', 'YYYY-MM-DD'), ' 00:00:00'), 'YYYY-MM-DD HH24:MI:SS') < created_at
      AND created_at <= to_timestamp(concat(to_char(current_date, 'YYYY-MM-DD'), ' 23:59:59'), 'YYYY-MM-DD HH24:MI:SS')
      GROUP BY main_type, sub_type, user_id
    );
IntervalType:
  desired: |
    CREATE TABLE public.test (
      col interval
    );
Comment:
  current: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      "foo" text NOT NULL DEFAULT ''::text,
      PRIMARY KEY ("id")
    );
  desired: |
    CREATE TABLE "public"."hoge" (
        "id" bigserial NOT NULL,
        "foo" text NOT NULL DEFAULT ''::text,
        PRIMARY KEY ("id")
    );

    COMMENT ON TABLE public.hoge is 'hoge table';
    COMMENT ON COLUMN public.hoge.id is 'hoge id';
    COMMENT ON COLUMN public.hoge.foo is 'foo comment';
  output: |
    COMMENT ON TABLE public.hoge is 'hoge table';
    COMMENT ON COLUMN public.hoge.id is 'hoge id';
    COMMENT ON COLUMN public.hoge.foo is 'foo comment';
MultipleComments:
  current: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "public"."bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON COLUMN public.hoge.id is 'hoge id';
  desired: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "public"."bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON COLUMN public.hoge.id is 'hoge id';
    COMMENT ON COLUMN public.bar.id is 'bar id';
  output: |
    COMMENT ON COLUMN public.bar.id is 'bar id';
UpdateComment:
  current: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "public"."bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON TABLE public.hoge is 'hoge table';
    COMMENT ON COLUMN public.hoge.id is 'hoge id';
    COMMENT ON TABLE public.bar is 'bar table';
    COMMENT ON COLUMN public.bar.id is 'bar id';
  desired: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "public"."bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON TABLE public.hoge is 'hoge table updated';
    COMMENT ON COLUMN public.hoge.id is 'hoge id updated';
    COMMENT ON TABLE public.bar is 'bar table';
    COMMENT ON COLUMN public.bar.id is 'bar id';
  output: |
    COMMENT ON TABLE public.hoge is 'hoge table updated';
    COMMENT ON COLUMN public.hoge.id is 'hoge id updated';
CommentOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE foo.users (
      id bigint
    );
  desired: |
    CREATE TABLE foo.users (
      id bigint
    );
    COMMENT ON TABLE foo.users is 'users table updated';
    COMMENT ON COLUMN foo.users.id is 'users id';
  output: |
    COMMENT ON TABLE foo.users is 'users table updated';
    COMMENT ON COLUMN foo.users.id is 'users id';
  user: psqldef_user
# This test removes existing comments by setting them to NULL
CommentUnset:
  current: |
    CREATE TABLE users (
      id bigint
    );
    COMMENT ON TABLE users IS 'users table is before update';
    COMMENT ON COLUMN users.id IS 'users id column is before update';
  desired: |
    CREATE TABLE users (
      id bigint
    );
    COMMENT ON TABLE users IS NULL;
    COMMENT ON COLUMN users.id IS null;
  output: |
    COMMENT ON TABLE public.users IS NULL;
    COMMENT ON COLUMN public.users.id IS null;
CommentNullWhenAlreadyNull:
  current: |
    CREATE TABLE "status" (
      "id" bigint NOT NULL
    );
  desired: |
    CREATE TABLE "status" (
      "id" bigint NOT NULL
    );
    COMMENT ON COLUMN "status"."id" IS NULL;
  output: ""
CommentWithoutSchema:
  current: |
    CREATE TABLE users (
      id bigint
    );
  desired: |
    CREATE TABLE users (
      id bigint
    );
    COMMENT ON TABLE users is 'users table is updated';
    COMMENT ON COLUMN users.id is 'users id column is updated';
  output: |
    COMMENT ON TABLE foo.users is 'users table is updated';
    COMMENT ON COLUMN foo.users.id is 'users id column is updated';
  user: psqldef_user # in cmd/psqldef/psqldef_test.go schema 'foo' is used if 'user' is provided.
CommentWithoutSchemaWithoutTableNameQuoted:
  current: |
    CREATE TABLE users (
      id bigint,
      "update" boolean
    );
  desired: |
    CREATE TABLE users (
      id bigint,
      "update" boolean
    );
    COMMENT ON TABLE users IS 'users table is updated';
    COMMENT ON COLUMN users.id IS 'users.id column is updated';
    COMMENT ON COLUMN users."update" IS '"users."update" column is updated';
  # Default schema 'public' is needed be prefixed in output to prevent false positive detection of DDL change.
  output: |
    COMMENT ON TABLE public.users IS 'users table is updated';
    COMMENT ON COLUMN public.users.id IS 'users.id column is updated';
    COMMENT ON COLUMN public.users."update" IS '"users."update" column is updated';
CommentWithoutSchemaWithTableNameQuoted:
  current: |
    CREATE TABLE "select" (
      id bigint,
      "update" boolean
    );
  desired: |
    CREATE TABLE "select" (
      id bigint,
      "update" boolean
    );
    COMMENT ON TABLE "select" IS '"select" table is updated';
    COMMENT ON COLUMN "select".id IS '"select".id column is updated';
    COMMENT ON COLUMN "select"."update" IS '"select"."update" column is updated';
  # Default schema 'public' is needed be prefixed in output to prevent false positive detection of DDL change.
  output: |
    COMMENT ON TABLE public."select" IS '"select" table is updated';
    COMMENT ON COLUMN public."select".id IS '"select".id column is updated';
    COMMENT ON COLUMN public."select"."update" IS '"select"."update" column is updated';

CommentContainingQuote:
  current: |
    CREATE TABLE public.test (
      email text
    );
  desired: |
    CREATE TABLE public.test (
      email text
    );
    COMMENT ON TABLE public.test is 'World''s best table';
    COMMENT ON COLUMN public.test.email is 'The user''s contact email address.';
  output: |
    COMMENT ON TABLE public.test is 'World''s best table';
    COMMENT ON COLUMN public.test.email is 'The user''s contact email address.';
CreateExtension:
  current: |
    CREATE EXTENSION pgcrypto;
  desired: |
    CREATE EXTENSION pgcrypto;
    CREATE EXTENSION btree_gist;
  output: |
    CREATE EXTENSION btree_gist;
DropExtension:
  current: |
    CREATE EXTENSION pgcrypto;
    CREATE EXTENSION btree_gist;
  desired:
    CREATE EXTENSION btree_gist;
  output: |
    DROP EXTENSION "pgcrypto";
CreateExtensionIfNotExists:
  desired: |
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
  output: |
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
CreateExtensionOrder:
  desired: |
    CREATE TABLE hoge (id UUID DEFAULT gen_random_uuid());
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
  output: |
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
    CREATE TABLE hoge (id UUID DEFAULT gen_random_uuid());
CreateTableAlterColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name varchar(40)
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "name" TYPE varchar(40);
CreateTableAddColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "age" integer;
CreateTableDropColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      age integer
    );
  output: |
    ALTER TABLE "public"."users" DROP COLUMN "name";
IndexesOnExpressions:
  current: |
    CREATE TABLE public.test (
      col JSONB
    );
  desired: |
    CREATE TABLE public.test (
      col JSONB
    );
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo', 'bar'));
  output: |
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo', 'bar'));
IndexesOnChangedExpressions:
  current: |
    CREATE TABLE public.test (
      col JSONB
    );
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo', 'bar'));
  desired: |
    CREATE TABLE public.test (
      col JSONB
    );
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo'));
  output: |
    DROP INDEX "public"."function_index";
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo'));
EscapeUniqueIndexQuery:
  current: |
    CREATE TABLE "userTable" (
        id uuid NOT NULL,
        "firstName" text,
        "lastName" text
    );
  desired: |
    CREATE TABLE "userTable" (
        id uuid NOT NULL,
        "firstName" text,
        "lastName" text
    );
    ALTER TABLE "public"."userTable" ADD CONSTRAINT "uq:fullName" UNIQUE ("firstName", "lastName");
  output: |
    ALTER TABLE "public"."userTable" ADD CONSTRAINT "uq:fullName" UNIQUE ("firstName", "lastName");
AddArrayColumn:
  current: |
    CREATE TABLE users (
      id integer
    );
  desired: |
    CREATE TABLE users (
      id integer,
      name integer[]
    );
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "name" integer[];
AddForeignKeyWithAlter:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE CASCADE;
  output: |
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE CASCADE;
AddDifferentForeignKeyWithSameName:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE CASCADE;
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON UPDATE CASCADE;
  output: |
    ALTER TABLE "public"."posts" DROP CONSTRAINT "posts_ibfk_1";
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON UPDATE CASCADE;
CreateTableOnNonStandardDefaultSchema:
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
    CREATE TABLE bigdata (
      data bigint
    );
  user: psqldef_user
DropTableOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
    CREATE TABLE bigdata (
      data bigint
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  output: |
    DROP TABLE "foo"."bigdata";
  user: psqldef_user

# Regression: boolean type must not be schema-qualified on non-public schema
AddBooleanColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      requires_consent boolean NOT NULL DEFAULT true
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "requires_consent" boolean NOT NULL DEFAULT true;
  user: psqldef_user

AddBooleanColumnWithExplicitSchema:
  current: |
    CREATE TABLE foo.items (
      id integer
    );
  desired: |
    CREATE TABLE foo.items (
      id integer,
      requires_consent boolean NOT NULL DEFAULT true
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "requires_consent" boolean NOT NULL DEFAULT true;
  user: psqldef_user

# User-defined enum type on non-public default schema (unqualified type usage)
AddEnumTypeColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TYPE lang AS ENUM (
      'ja',
      'en'
    );

    CREATE TABLE items (
      id integer,
      lang lang NOT NULL
    );
  output: |
    CREATE TYPE lang AS ENUM (
      'ja',
      'en'
    );
    ALTER TABLE "foo"."items" ADD COLUMN "lang" lang NOT NULL;
  user: psqldef_user

# User-defined enum type on non-public default schema (explicit schema usage)
AddEnumTypeColumnWithExplicitSchemaOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TYPE foo.lang AS ENUM (
      'ja',
      'en'
    );

    CREATE TABLE items (
      id integer,
      lang foo.lang NOT NULL
    );
  output: |
    CREATE TYPE foo.lang AS ENUM (
      'ja',
      'en'
    );
    ALTER TABLE "foo"."items" ADD COLUMN "lang" foo.lang NOT NULL;
  user: psqldef_user

# Built-in types must not be schema-qualified on non-public schema
AddIntegerColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      count integer NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "count" integer NOT NULL;
  user: psqldef_user

AddTextColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      description text NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "description" text NOT NULL;
  user: psqldef_user

AddVarcharColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      name varchar(255) NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "name" varchar(255) NOT NULL;
  user: psqldef_user

AddNumericColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      amount numeric(10, 2) NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "amount" numeric(10, 2) NOT NULL;
  user: psqldef_user

AddUUIDColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      uuid_col uuid NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "uuid_col" uuid NOT NULL;
  user: psqldef_user

AddJSONBColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      meta jsonb NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "meta" jsonb NOT NULL;
  user: psqldef_user

AddTimestampColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      ts timestamp NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "ts" timestamp NOT NULL;
  user: psqldef_user

AddTimestamptzColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      ts_tz timestamptz NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "ts_tz" timestamp WITH TIME ZONE NOT NULL;
  user: psqldef_user

AddTimetzColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      time_tz timetz NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "time_tz" time WITH TIME ZONE NOT NULL;
  user: psqldef_user

AddDoublePrecisionColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      dp double precision NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "dp" double precision NOT NULL;
  user: psqldef_user

AddRealColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      rp real NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "rp" real NOT NULL;
  user: psqldef_user

AddByteaColumnOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE items (
      id integer
    );
  desired: |
    CREATE TABLE items (
      id integer,
      data bytea NOT NULL
    );
  output: |
    ALTER TABLE "foo"."items" ADD COLUMN "data" bytea NOT NULL;
  user: psqldef_user
ChangeTimezone:
  current: |
    CREATE TABLE test (
      timestamp_at1 timestamp with time zone NOT NULL,
      timestamp_at2 timestamp with time zone NOT NULL,
      timestamp_at3 timestamp NOT NULL,
      timestamp_at4 timestamp WITHOUT TIME ZONE NOT NULL,
      time_at1 time WITH TIME ZONE NOT NULL,
      time_at2 time WITH TIME ZONE NOT NULL,
      time_at3 time NOT NULL,
      time_at4 time WITHOUT TIME ZONE NOT NULL
    );
  desired: |
    CREATE TABLE test (
      timestamp_at1 timestamp WITHOUT TIME ZONE NOT NULL,
      timestamp_at2 timestamp NOT NULL,
      timestamp_at3 timestamp WITH TIME ZONE NOT NULL,
      timestamp_at4 timestamp WITH TIME ZONE NOT NULL,
      time_at1 time WITHOUT TIME ZONE NOT NULL,
      time_at2 time NOT NULL,
      time_at3 time WITH TIME ZONE NOT NULL,
      time_at4 time WITH TIME ZONE NOT NULL
    );
  output: |
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_at1" TYPE timestamp;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_at2" TYPE timestamp;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_at3" TYPE timestamp WITH TIME ZONE;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_at4" TYPE timestamp WITH TIME ZONE;
    ALTER TABLE "public"."test" ALTER COLUMN "time_at1" TYPE time;
    ALTER TABLE "public"."test" ALTER COLUMN "time_at2" TYPE time;
    ALTER TABLE "public"."test" ALTER COLUMN "time_at3" TYPE time WITH TIME ZONE;
    ALTER TABLE "public"."test" ALTER COLUMN "time_at4" TYPE time WITH TIME ZONE;
ChangeTimezoneSyntax:
  current: |
    CREATE TABLE test (
      timestamp_wtz_wtz     timestamp with time zone,
      timestamp_wtz_tz      timestamp with time zone,
      timestamp_wtz_plain   timestamp with time zone,
      timestamp_tz_wtz      timestamptz,
      timestamp_tz_tz       timestamptz,
      timestamp_tz_plain    timestamptz,
      timestamp_plain_wtz   timestamp,
      timestamp_plain_tz    timestamp,
      timestamp_plain_plain timestamp
    );
  desired: |
    CREATE TABLE test (
      timestamp_wtz_wtz     timestamp with time zone,
      timestamp_wtz_tz      timestamptz,
      timestamp_wtz_plain   timestamp,
      timestamp_tz_wtz      timestamp with time zone,
      timestamp_tz_tz       timestamptz,
      timestamp_tz_plain    timestamp,
      timestamp_plain_wtz   timestamp with time zone,
      timestamp_plain_tz    timestamptz,
      timestamp_plain_plain timestamp
    );
  output: |
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_wtz_plain" TYPE timestamp;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_tz_plain" TYPE timestamp;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_plain_wtz" TYPE timestamp WITH TIME ZONE;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_plain_tz" TYPE timestamp WITH TIME ZONE;
CreateTableAddTimestampColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer,
      timestamp_with_tz timestamp WITH TIME ZONE,
      timestamp_without_tz timestamp WITHOUT TIME ZONE
    );
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "timestamp_with_tz" timestamp WITH TIME ZONE;
    ALTER TABLE "public"."users" ADD COLUMN "timestamp_without_tz" timestamp;
AddColumnWithDefaultExpression:
  current: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (id bigint NOT NULL);
  desired: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL DEFAULT uuid_generate_v4()
    );
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "key" uuid NOT NULL DEFAULT uuid_generate_v4();
AddDefaultExpression:
  current: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL
    );
  desired: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL DEFAULT uuid_generate_v4()
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "key" SET DEFAULT uuid_generate_v4();
RemoveDefaultExpression:
  current: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL DEFAULT uuid_generate_v4()
    );
  desired: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "key" DROP DEFAULT;
ChangeDefaultExpressionWithAddition:
  current: |
    CREATE TABLE public.foo (
      expires_at timestamp with time zone NOT NULL DEFAULT (CURRENT_TIMESTAMP + '1 day'::interval)
    );
  desired: |
    CREATE TABLE public.foo (
      expires_at timestamp with time zone NOT NULL DEFAULT (CURRENT_TIMESTAMP + '3 days'::interval)
    );
  output: |
    ALTER TABLE "public"."foo" ALTER COLUMN "expires_at" SET DEFAULT current_timestamp + '3 days'::interval;
CreateTableAddAbsentForeignKey:
  current: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE posts (
      content TEXT,
      user_id INT
    );
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE posts (
      content TEXT,
      user_id INT REFERENCES users(id)
    );
  output: |
    ALTER TABLE "public"."posts" ADD CONSTRAINT "posts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users" ("id");
CreateTableWithConstraintOptions:
  current: |
    CREATE TABLE images (
      id INT PRIMARY KEY
    );
    CREATE TABLE image_owners (
      id INT,
      type VARCHAR(20) NOT NULL,
      PRIMARY KEY (type, id)
    );
    CREATE TABLE image_bindings (
      image_id INT REFERENCES images(id) ON DELETE CASCADE,
      image_order INT NOT NULL,
      image_owner_type VARCHAR(20) NOT NULL,
      image_owner_id INT NOT NULL,
      CONSTRAINT image_owner_fk FOREIGN KEY (image_owner_type, image_owner_id) REFERENCES image_owners(type, id) ON DELETE CASCADE,
      CONSTRAINT image_order_unique UNIQUE (image_owner_type, image_owner_id, image_order)
    );
  desired: |
    CREATE TABLE images (
      id INT PRIMARY KEY
    );
    CREATE TABLE image_owners (
      id INT,
      type VARCHAR(20) NOT NULL,
      PRIMARY KEY (type, id)
    );
    CREATE TABLE image_bindings (
      image_id INT REFERENCES images(id) ON DELETE CASCADE DEFERRABLE INITIALLY IMMEDIATE,
      image_order INT NOT NULL,
      image_owner_type VARCHAR(20) NOT NULL,
      image_owner_id INT NOT NULL,
      CONSTRAINT image_owner_fk FOREIGN KEY (image_owner_type, image_owner_id) REFERENCES image_owners(type, id) ON DELETE CASCADE DEFERRABLE INITIALLY IMMEDIATE,
      CONSTRAINT image_order_unique UNIQUE (image_owner_type, image_owner_id, image_order) DEFERRABLE INITIALLY DEFERRED
    );
  output: |
    ALTER TABLE "public"."image_bindings" DROP CONSTRAINT "image_order_unique";
    ALTER TABLE "public"."image_bindings" ADD CONSTRAINT "image_order_unique" UNIQUE ("image_owner_type", "image_owner_id", "image_order") DEFERRABLE INITIALLY DEFERRED;
    ALTER TABLE "public"."image_bindings" DROP CONSTRAINT "image_bindings_image_id_fkey";
    ALTER TABLE "public"."image_bindings" DROP CONSTRAINT "image_owner_fk";
    ALTER TABLE "public"."image_bindings" ADD CONSTRAINT "image_bindings_image_id_fkey" FOREIGN KEY ("image_id") REFERENCES "public"."images" ("id") ON DELETE CASCADE DEFERRABLE INITIALLY IMMEDIATE;
    ALTER TABLE "public"."image_bindings" ADD CONSTRAINT "image_owner_fk" FOREIGN KEY ("image_owner_type","image_owner_id") REFERENCES "public"."image_owners" ("type","id") ON DELETE CASCADE DEFERRABLE INITIALLY IMMEDIATE;
CreateTableWithForeignKeyAndGeneratedColumn:
  min_version: '12'
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE emails (
      user_id INT NOT NULL,
      local_part VARCHAR(100) NOT NULL,
      domain VARCHAR(100) NOT NULL,
      lower_address TEXT GENERATED ALWAYS AS (LOWER(local_part || '@' || domain)) STORED NOT NULL,
      PRIMARY KEY (domain, local_part),
      CONSTRAINT user_fk FOREIGN KEY (user_id) REFERENCES users(id)
    );
CaseWithoutArgument:
  desired: |
    CREATE TABLE permissions (
      name TEXT NOT NULL,
      admin BOOLEAN NOT NULL,
      CONSTRAINT admin_name CHECK (
        CASE
          WHEN admin THEN name LIKE 'admin%'
          ELSE true
        END
      )
    );
LongAutoGeneratedForeignKeyConstraint:
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE loooooooooooooooooooooooooooooooooooooooong_table_63_characters (
      -- loooooooooooooooooooooooooooooooooooooooong_table_63_cha_a_fkey
      a INT NOT NULL REFERENCES users (id)
    );
    CREATE TABLE loooooong_table_29_characters (
      -- loooooong_table_29_characters_loooong_column_28_characters_fkey
      loooong_column_28_characters INT NOT NULL REFERENCES users (id),

      -- loooooong_table_29_characters_looooong_column_29_character_fkey
      looooong_column_29_characters INT NOT NULL REFERENCES users (id)
    );
    CREATE TABLE looooooong_table_30_characters (
      -- looooooong_table_30_character_looooong_column_29_character_fkey
      looooong_column_29_characters INT NOT NULL REFERENCES users (id),

      -- looooooong_table_30_character_loooong_column_28_characters_fkey
      loooong_column_28_characters INT NOT NULL REFERENCES users (id),

      -- looooooong_table_30_characters_looong_column_27_characters_fkey
      looong_column_27_characters INT NOT NULL REFERENCES users (id)
    );
    CREATE TABLE a (
      -- a_looooooooooooooooooooooooooooooooong_column_57_character_fkey
      looooooooooooooooooooooooooooooooong_column_57_characters INT NOT NULL REFERENCES users (id),

      -- a_loooooooooooooooooooooooooooooooong_column_56_characters_fkey
      loooooooooooooooooooooooooooooooong_column_56_characters INT NOT NULL REFERENCES users (id)
    );
LongAutoGeneratedCheckConstraint:
  desired: |
    CREATE TABLE loooooooooooooooooooooooooooooooooooooooong_table_63_characters (
      -- loooooooooooooooooooooooooooooooooooooooong_table_63_ch_a_check
      a INT NOT NULL CHECK (a > 0)
    );
    CREATE TABLE loooooong_table_29_characters (
      -- loooooong_table_29_characters_looong_column_27_characters_check
      looong_column_27_characters INT NOT NULL CHECK (looong_column_27_characters > 0),

      -- loooooong_table_29_characters_loooong_column_28_character_check
      loooong_column_28_characters INT NOT NULL CHECK (loooong_column_28_characters > 0),

      -- loooooong_table_29_character_looooong_column_29_character_check
      looooong_column_29_characters INT NOT NULL CHECK (looooong_column_29_characters > 0)
    );
    CREATE TABLE looooooong_table_30_characters (
      -- looooooong_table_30_characters_loong_column_26_characters_check
      loong_column_26_characters INT NOT NULL CHECK (loong_column_26_characters > 0),

      -- looooooong_table_30_character_looong_column_27_characters_check
      looong_column_27_characters INT NOT NULL CHECK (looong_column_27_characters > 0),

      -- looooooong_table_30_characte_loooong_column_28_characters_check
      loooong_column_28_characters INT NOT NULL CHECK (loooong_column_28_characters > 0)
    );
    CREATE TABLE a (
      -- a_loooooooooooooooooooooooooooooooong_column_56_character_check
      loooooooooooooooooooooooooooooooong_column_56_characters INT NOT NULL CHECK (loooooooooooooooooooooooooooooooong_column_56_characters > 0),

      -- a_looooooooooooooooooooooooooooooong_column_55_characters_check
      looooooooooooooooooooooooooooooong_column_55_characters INT NOT NULL CHECK (looooooooooooooooooooooooooooooong_column_55_characters > 0)
    );

CreateSchema:
  desired: |
    CREATE TABLE foo.test (id int);
    CREATE SCHEMA foo;
    CREATE SCHEMA IF NOT EXISTS bar;
  output: |
    CREATE SCHEMA foo;
    CREATE SCHEMA IF NOT EXISTS bar;
    CREATE TABLE foo.test (id int);

CreateSchemasWithDomains:
  desired: |
    CREATE SCHEMA test_schema_a;
    CREATE SCHEMA test_schema_b;
    CREATE DOMAIN test_schema_a.amount AS integer CHECK (VALUE > 0);
    CREATE DOMAIN test_schema_b.amount AS integer CHECK (VALUE < 0);
    CREATE DOMAIN test_schema_a.email AS text CHECK (VALUE ~ '@');
    CREATE DOMAIN test_schema_b.status AS text DEFAULT 'pending';

ExcludeConstraintWithCreateTable:
  desired: |
    CREATE TABLE exclude_example (
      name varchar(255),
      event_start tstzrange NOT NULL,
      event_end tstzrange NOT NULL,
      CONSTRAINT ex1 EXCLUDE (name WITH =),
      CONSTRAINT ex2 EXCLUDE (lower(name::text) WITH =) where (name::text <> ''),
      CONSTRAINT ex3 EXCLUDE USING GIST (event_start WITH &&, event_end WITH &&)
    );

ExcludeConstraintChange:
  current: |
    CREATE TABLE exclude_example (
      name varchar(255),
      event_start tstzrange NOT NULL,
      event_end tstzrange NOT NULL,
      CONSTRAINT ex EXCLUDE (name WITH =)
    );
  desired: |
    CREATE TABLE exclude_example (
      name varchar(255),
      event_start tstzrange NOT NULL,
      event_end tstzrange NOT NULL,
      CONSTRAINT ex EXCLUDE USING GIST (event_start WITH &&, event_end WITH &&)
    );
  output: |
    ALTER TABLE "public"."exclude_example" DROP CONSTRAINT "ex";
    ALTER TABLE "public"."exclude_example" ADD CONSTRAINT "ex" EXCLUDE USING GIST (event_start WITH &&, event_end WITH &&);

ExcludeConstraintDropAndAdd:
  current: |
    CREATE TABLE exclude_example (
      name varchar(255),
      event_start tstzrange NOT NULL,
      event_end tstzrange NOT NULL,
      CONSTRAINT ex1 EXCLUDE (name WITH =)
    );
  desired: |
    CREATE TABLE exclude_example (
      name varchar(255),
      event_start tstzrange NOT NULL,
      event_end tstzrange NOT NULL,
      CONSTRAINT ex2 EXCLUDE USING GIST (event_start WITH &&, event_end WITH &&)
    );
  output: |
    ALTER TABLE "public"."exclude_example" ADD CONSTRAINT "ex2" EXCLUDE USING GIST (event_start WITH &&, event_end WITH &&);
    ALTER TABLE "public"."exclude_example" DROP CONSTRAINT "ex1";

ExcludeConstraintWithAlterTable:
  current: |
    CREATE TABLE exclude_example (
      name varchar(255),
      event_start tstzrange NOT NULL,
      event_end tstzrange NOT NULL
    );
    ALTER TABLE exclude_example ADD CONSTRAINT ex1 EXCLUDE (name WITH =);
  desired: |
    CREATE TABLE exclude_example (
      name varchar(255),
      event_start tstzrange NOT NULL,
      event_end tstzrange NOT NULL
    );
    ALTER TABLE exclude_example ADD CONSTRAINT ex2 EXCLUDE USING GIST (event_start WITH &&, event_end WITH &&);
  output: |
    ALTER TABLE exclude_example ADD CONSTRAINT ex2 EXCLUDE USING GIST (event_start WITH &&, event_end WITH &&);
    ALTER TABLE "public"."exclude_example" DROP CONSTRAINT "ex1";
CollateOnColumn:
  desired: |
    create table users
    (
        id   int          not null,
        name varchar(255) not null
    );
    create view user_view as
    select users.id,
          (users.name collate "ja-JP-x-icu") as name
    from users;

RenameColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      username text,
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      user_name text, -- @renamed from=username
      age integer
    );
  output: |
    ALTER TABLE "public"."users" RENAME COLUMN "username" TO "user_name";

RenameColumnWithTypeChange:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      username varchar(100),
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      user_name text NOT NULL, -- @renamed from=username
      age integer
    );
  output: |
    ALTER TABLE "public"."users" RENAME COLUMN "username" TO "user_name";
    ALTER TABLE "public"."users" ALTER COLUMN "user_name" TYPE text;
    ALTER TABLE "public"."users" ALTER COLUMN "user_name" SET NOT NULL;

RenameColumnIdempotency:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      user_name text,
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      user_name text, -- @renamed from=username
      age integer
    );
  output: ""

RenameColumnConflictingNames:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      username text,
      user_name varchar(50),
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      username text,
      user_name varchar(100), -- @renamed from=username
      age integer
    );
  error: "cannot rename column 'username' to 'user_name' - column 'username' still exists"

RenameColumnQuotedDoubleQuotes:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      "foo bar" text,
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      foobar text, -- @renamed from="foo bar"
      age integer
    );
  output: |
    ALTER TABLE "public"."users" RENAME COLUMN "foo bar" TO "foobar";

RenameColumnWithSpecialChars:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      "column-with-dash" varchar(50),
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      column_with_underscore varchar(50), -- @renamed from="column-with-dash"
      age integer
    );
  output: |
    ALTER TABLE "public"."users" RENAME COLUMN "column-with-dash" TO "column_with_underscore";

RenameColumnWithDot:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      "special.column" text NOT NULL,
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      special_column text NOT NULL, -- @renamed from="special.column"
      age integer
    );
  output: |
    ALTER TABLE "public"."users" RENAME COLUMN "special.column" TO "special_column";

RenameMultipleColumns:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      "user name" text,
      "email@address" varchar(100),
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      username text, -- @renamed from="user name"
      email_address varchar(100), -- @renamed from="email@address"
      age integer
    );
  output: |
    ALTER TABLE "public"."users" RENAME COLUMN "user name" TO "username";
    ALTER TABLE "public"."users" RENAME COLUMN "email@address" TO "email_address";

RenameTable:
  current: |
    CREATE TABLE user_accounts (
      id bigint NOT NULL,
      username text,
      age integer
    );
  desired: |
    CREATE TABLE users ( -- @renamed from=user_accounts
      id bigint NOT NULL,
      username text,
      age integer
    );
  output: |
    ALTER TABLE "public"."user_accounts" RENAME TO "users";

RenameTableWithCommentVariant:
  current: |
    CREATE TABLE old_users (
      id bigint NOT NULL,
      name text
    );
  desired: |
    CREATE TABLE new_users /* @renamed from=old_users */ (
      id bigint NOT NULL,
      name text
    );
  output: |
    ALTER TABLE "public"."old_users" RENAME TO "new_users";

RenameTableWithQuotedName:
  current: |
    CREATE TABLE "user accounts" (
      id bigint NOT NULL,
      name text
    );
  desired: |
    CREATE TABLE "user_profiles" ( -- @renamed from="user accounts"
      id bigint NOT NULL,
      name text
    );
  output: |
    ALTER TABLE "public"."user accounts" RENAME TO "user_profiles";

RenameTableAndMultipleChanges:
  current: |
    CREATE TABLE old_accounts (
      id bigint NOT NULL,
      user_name varchar(50),
      is_active boolean,
      old_field text
    );
  desired: |
    CREATE TABLE accounts ( -- @renamed from=old_accounts
      id bigint NOT NULL PRIMARY KEY,
      username varchar(100) NOT NULL, -- @renamed from=user_name
      is_active boolean DEFAULT true,
      created_at timestamp DEFAULT CURRENT_TIMESTAMP
    );
  output: |
    ALTER TABLE "public"."old_accounts" RENAME TO "accounts";
    ALTER TABLE "public"."accounts" RENAME COLUMN "user_name" TO "username";
    ALTER TABLE "public"."accounts" ALTER COLUMN "username" TYPE varchar(100);
    ALTER TABLE "public"."accounts" ALTER COLUMN "username" SET NOT NULL;
    ALTER TABLE "public"."accounts" ALTER COLUMN "is_active" SET DEFAULT true;
    ALTER TABLE "public"."accounts" ADD COLUMN "created_at" timestamp DEFAULT current_timestamp;
    ALTER TABLE "public"."accounts" ADD PRIMARY KEY ("id");
    ALTER TABLE "public"."accounts" DROP COLUMN "old_field";

ConstraintCheckInWithUniqueCreate:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL
    );
    CREATE TABLE animals (
      id serial,
      age INTEGER CHECK (age IN (0, 1, 2, 3, 4, 5)),
      UNIQUE (age)
    );
  output: |
    CREATE TABLE animals (
      id serial,
      age INTEGER CHECK (age IN (0, 1, 2, 3, 4, 5)),
      UNIQUE (age)
    );

ConstraintCheckInAdd:
  current: |
    CREATE TABLE products (
      id serial,
      status text
    );
  desired: |
    CREATE TABLE products (
      id serial,
      status text CHECK (status IN ('active', 'inactive', 'pending'))
    );
  output: |
    ALTER TABLE "public"."products" ADD CONSTRAINT "products_status_check" CHECK (status = ANY (ARRAY['active', 'inactive', 'pending']));

ConstraintCheckInRemove:
  current: |
    CREATE TABLE products (
      id serial,
      status text CHECK (status IN ('active', 'inactive', 'pending'))
    );
  desired: |
    CREATE TABLE products (
      id serial,
      status text
    );
  output: |
    ALTER TABLE "public"."products" DROP CONSTRAINT "products_status_check";

ConstraintUniqueAdd:
  current: |
    CREATE TABLE products (
      id serial,
      sku text
    );
  desired: |
    CREATE TABLE products (
      id serial,
      sku text,
      UNIQUE (sku)
    );
  output: |
    ALTER TABLE "public"."products" ADD CONSTRAINT "products_sku_key" UNIQUE ("sku");

ConstraintUniqueRemove:
  current: |
    CREATE TABLE products (
      id serial,
      sku text,
      UNIQUE (sku)
    );
  desired: |
    CREATE TABLE products (
      id serial,
      sku text
    );
  output: |
    ALTER TABLE "public"."products" DROP CONSTRAINT "products_sku_key";

ConstraintCheckInModify:
  current: |
    CREATE TABLE products (
      id serial,
      priority integer CHECK (priority IN (1, 2, 3))
    );
  desired: |
    CREATE TABLE products (
      id serial,
      priority integer CHECK (priority IN (1, 2, 3, 4, 5))
    );
  output: |
    ALTER TABLE "public"."products" DROP CONSTRAINT "products_priority_check";
    ALTER TABLE "public"."products" ADD CONSTRAINT "products_priority_check" CHECK (priority = ANY (ARRAY[1, 2, 3, 4, 5]));

ConstraintCheckInAndUniqueAdd:
  current: |
    CREATE TABLE products (
      id serial,
      level integer
    );
  desired: |
    CREATE TABLE products (
      id serial,
      level integer CHECK (level IN (1, 2, 3, 4)),
      UNIQUE (level)
    );
  output: |
    ALTER TABLE "public"."products" ADD CONSTRAINT "products_level_check" CHECK (level = ANY (ARRAY[1, 2, 3, 4]));
    ALTER TABLE "public"."products" ADD CONSTRAINT "products_level_key" UNIQUE ("level");

ConstraintCheckInAndUniqueRemove:
  current: |
    CREATE TABLE products (
      id serial,
      level integer CHECK (level IN (1, 2, 3, 4)),
      UNIQUE (level)
    );
  desired: |
    CREATE TABLE products (
      id serial,
      level integer
    );
  output: |
    ALTER TABLE "public"."products" DROP CONSTRAINT "products_level_check";
    ALTER TABLE "public"."products" DROP CONSTRAINT "products_level_key";

ConstraintCheckInMultipleColumnsWithUnique:
  current: |
    CREATE TABLE orders (
      id serial,
      priority integer,
      category integer
    );
  desired: |
    CREATE TABLE orders (
      id serial,
      priority integer CHECK (priority IN (1, 2, 3)),
      category integer CHECK (category IN (10, 20, 30, 40)),
      UNIQUE (priority, category)
    );
  output: |
    ALTER TABLE "public"."orders" ADD CONSTRAINT "orders_priority_check" CHECK (priority = ANY (ARRAY[1, 2, 3]));
    ALTER TABLE "public"."orders" ADD CONSTRAINT "orders_category_check" CHECK (category = ANY (ARRAY[10, 20, 30, 40]));
    ALTER TABLE "public"."orders" ADD CONSTRAINT "priority" UNIQUE ("priority", "category");

RenameIndex:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX old_email_idx ON users (email);
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX new_email_idx /* @renamed from=old_email_idx */ ON users (email);
  output: |
    ALTER INDEX "public"."old_email_idx" RENAME TO "new_email_idx";

RenameIndexInTable:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100),
      CONSTRAINT old_unique_email UNIQUE (email)
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100),
      CONSTRAINT unique_email UNIQUE (email) -- @renamed from=old_unique_email
    );
  output: |
    ALTER INDEX "public"."old_unique_email" RENAME TO "unique_email";

RenameMultipleIndexes:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX idx_email ON users (email);
    CREATE INDEX idx_username ON users (username);
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX email_idx /* @renamed from=idx_email */ ON users (email);
    CREATE INDEX username_idx /* @renamed from=idx_username */ ON users (username);
  output: |
    ALTER INDEX "public"."idx_email" RENAME TO "email_idx";
    ALTER INDEX "public"."idx_username" RENAME TO "username_idx";

RenameIndexInNonDefaultSchema:
  current: |
    CREATE SCHEMA myschema;
    CREATE TABLE myschema.users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX old_email_idx ON myschema.users (email);
  desired: |
    CREATE TABLE myschema.users (
      id bigint NOT NULL,
      email varchar(255),
      username varchar(100)
    );
    CREATE INDEX new_email_idx /* @renamed from=old_email_idx */ ON myschema.users (email);
  output: |
    ALTER INDEX "myschema"."old_email_idx" RENAME TO "new_email_idx";

CreateIndexWithConcurrentlyConfig:
  config:
    create_index_concurrently: true
  current: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128),
      email VARCHAR(255)
    );
  desired: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128),
      email VARCHAR(255)
    );
    CREATE INDEX idx_users_name ON users (name);
    CREATE INDEX idx_users_email ON users (email);
  output: |
    CREATE INDEX CONCURRENTLY idx_users_name ON users (name);
    CREATE INDEX CONCURRENTLY idx_users_email ON users (email);

CreateUniqueIndexWithConcurrentlyConfig:
  config:
    create_index_concurrently: true
  current: |
    CREATE TABLE products (
      id BIGINT NOT NULL PRIMARY KEY,
      sku VARCHAR(100)
    );
  desired: |
    CREATE TABLE products (
      id BIGINT NOT NULL PRIMARY KEY,
      sku VARCHAR(100)
    );
    CREATE UNIQUE INDEX idx_products_sku ON products (sku);
  output: |
    CREATE UNIQUE INDEX CONCURRENTLY idx_products_sku ON products (sku);

CreateIndexWithConcurrentlyConfigMixedStatements:
  config:
    create_index_concurrently: true
  current: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128)
    );
  desired: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128),
      email VARCHAR(255)
    );
    CREATE INDEX idx_users_name ON users (name);
    CREATE INDEX CONCURRENTLY idx_users_email_manual ON users (email);
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "email" varchar(255);
    CREATE INDEX CONCURRENTLY idx_users_name ON users (name);
    CREATE INDEX CONCURRENTLY idx_users_email_manual ON users (email);

CreateIndexWithoutConcurrentlyConfig:
  config:
    create_index_concurrently: false
  current: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128)
    );
  desired: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128)
    );
    CREATE INDEX idx_users_name ON users (name);
  output: |
    CREATE INDEX idx_users_name ON users (name);

CreateIdentityColumnWithNegativeValue:
  desired: |
    CREATE TABLE test_sequence_negative (
      id1 bigint GENERATED ALWAYS AS IDENTITY (
        START WITH -100
        INCREMENT BY -5
        MINVALUE -1000
        MAXVALUE -10
        CACHE 20
      ),
      id2 bigint GENERATED ALWAYS AS IDENTITY (
        START -50
        INCREMENT -2
      ),
      id3 bigint GENERATED ALWAYS AS IDENTITY (
        MINVALUE -500
        MAXVALUE 0
      ),
      id4 bigint GENERATED ALWAYS AS IDENTITY (
        START WITH -1
        INCREMENT BY 1
        MINVALUE -100
        MAXVALUE 100
        CACHE 10
      )
    );

CreateTableWithCheckConstraints:
  current: |
    CREATE TABLE "public"."domains" (
      "id" serial NOT NULL,
      "name" character varying(255) NOT NULL CONSTRAINT c_lowercase_name CHECK (name::text = lower(name::text)),
      PRIMARY KEY ("id")
    );
  desired: |
    CREATE TABLE "public"."domains" (
      id                    SERIAL PRIMARY KEY,
      name                  VARCHAR(255) NOT NULL,
      CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
    );
  output: ""

CreateTableWithCurrentTimestamp:
  desired: |
    CREATE TABLE timestamps (
      created_at timestamp default current_timestamp
    );

DropTimestampDefault:
  current: |
    CREATE TABLE timestamps (
      created_at timestamp default current_timestamp
    );
  desired: |
    CREATE TABLE timestamps (
      created_at timestamp
    );
  output: |
    ALTER TABLE "public"."timestamps" ALTER COLUMN "created_at" DROP DEFAULT;

AddTimestampDefaultBack:
  current: |
    CREATE TABLE timestamps (
      created_at timestamp
    );
  desired: |
    CREATE TABLE timestamps (
      created_at timestamp default current_timestamp
    );
  output: |
    ALTER TABLE "public"."timestamps" ALTER COLUMN "created_at" SET DEFAULT current_timestamp;

CreateTableWithoutNotNull:
  desired: |
    CREATE TABLE users (
      name text
    );

AddNotNullConstraint:
  current: |
    CREATE TABLE users (
      name text
    );
  desired: |
    CREATE TABLE users (
      name text NOT NULL
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "name" SET NOT NULL;

DropNotNullConstraint:
  current: |
    CREATE TABLE users (
      name text NOT NULL
    );
  desired: |
    CREATE TABLE users (
      name text
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "name" DROP NOT NULL;

CreateTableWithPrimaryKey:
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL PRIMARY KEY,
      name text
    );

DropPrimaryKeyAndColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL PRIMARY KEY,
      name text
    );
  desired: |
    CREATE TABLE users (
      name text
    );
  output: |
    ALTER TABLE "public"."users" DROP CONSTRAINT "users_pkey";
    ALTER TABLE "public"."users" DROP COLUMN "id";

AddPrimaryKeyAndColumnBack:
  current: |
    CREATE TABLE users (
      name text
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL PRIMARY KEY,
      name text
    );
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "id" bigint NOT NULL;
    ALTER TABLE "public"."users" ADD PRIMARY KEY ("id");

ConstraintPrimaryKey:
  desired: |
    CREATE TABLE users (
      a integer,
      b integer,
      CONSTRAINT a_b_pkey PRIMARY KEY (a, b)
    );

CreateTablesWithoutForeignKey:
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );

AddForeignKeyConstraint:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint,
      CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id)
    );
  output: |
    ALTER TABLE "public"."posts" ADD CONSTRAINT "posts_ibfk_1" FOREIGN KEY ("user_id") REFERENCES "public"."users" ("id");

ModifyForeignKeyActions:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint,
      CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id)
    );
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint,
      CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE CASCADE
    );
  output: |
    ALTER TABLE "public"."posts" DROP CONSTRAINT "posts_ibfk_1";
    ALTER TABLE "public"."posts" ADD CONSTRAINT "posts_ibfk_1" FOREIGN KEY ("user_id") REFERENCES "public"."users" ("id") ON DELETE SET NULL ON UPDATE CASCADE;

RemoveForeignKeyConstraint:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint,
      CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE CASCADE
    );
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
  output: |
    ALTER TABLE "public"."posts" DROP CONSTRAINT "posts_ibfk_1";

CreateTableWithReferences:
  desired: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY,
      my_text TEXT UNIQUE NOT NULL
    );
    CREATE TABLE b (
      b_id INTEGER PRIMARY KEY,
      a_id INTEGER REFERENCES a,
      a_my_text TEXT NOT NULL REFERENCES a (my_text)
    );

DropReferences:
  current: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY,
      my_text TEXT UNIQUE NOT NULL
    );
    CREATE TABLE b (
      b_id INTEGER PRIMARY KEY,
      a_id INTEGER REFERENCES a,
      a_my_text TEXT NOT NULL REFERENCES a (my_text)
    );
  desired: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY,
      my_text TEXT UNIQUE NOT NULL
    );
    CREATE TABLE b (
      b_id INTEGER PRIMARY KEY,
      a_id INTEGER,
      a_my_text TEXT NOT NULL
    );
  output: |
    ALTER TABLE "public"."b" DROP CONSTRAINT "b_a_id_fkey";
    ALTER TABLE "public"."b" DROP CONSTRAINT "b_a_my_text_fkey";

ReferencesWithOnDeleteCascade:
  desired: |
    CREATE TABLE customers (
      id UUID NOT NULL PRIMARY KEY,
      customer_name VARCHAR(255) NOT NULL
    );
    CREATE TABLE orders (
      id UUID NOT NULL PRIMARY KEY,
      order_number VARCHAR(255) NOT NULL,
      customer UUID REFERENCES customers(id) ON DELETE CASCADE
    );

ColumnCheckConstraint:
  desired: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY CHECK (a_id > 0),
      my_text TEXT UNIQUE NOT NULL
    );

ModifyColumnCheckConstraint:
  current: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY CHECK (a_id > 0),
      my_text TEXT UNIQUE NOT NULL
    );
  desired: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY CHECK (a_id > 1),
      my_text TEXT UNIQUE NOT NULL
    );
  output: |
    ALTER TABLE "public"."a" DROP CONSTRAINT "a_a_id_check";
    ALTER TABLE "public"."a" ADD CONSTRAINT "a_a_id_check" CHECK (a_id > 1);

DropCheckConstraint:
  current: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY CHECK (a_id > 1),
      my_text TEXT UNIQUE NOT NULL
    );
  desired: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY,
      my_text TEXT UNIQUE NOT NULL
    );
  output: |
    ALTER TABLE "public"."a" DROP CONSTRAINT "a_a_id_check";

AddCheckConstraintNoInherit:
  current: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY,
      my_text TEXT UNIQUE NOT NULL
    );
  desired: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY CHECK (a_id > 2) NO INHERIT,
      my_text TEXT UNIQUE NOT NULL
    );
  output: |
    ALTER TABLE "public"."a" ADD CONSTRAINT "a_a_id_check" CHECK (a_id > 2) NO INHERIT;

ModifyCheckConstraintNoInherit:
  current: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY CHECK (a_id > 2) NO INHERIT,
      my_text TEXT UNIQUE NOT NULL
    );
  desired: |
    CREATE TABLE a (
      a_id INTEGER PRIMARY KEY CHECK (a_id > 3) NO INHERIT,
      my_text TEXT UNIQUE NOT NULL
    );
  output: |
    ALTER TABLE "public"."a" DROP CONSTRAINT "a_a_id_check";
    ALTER TABLE "public"."a" ADD CONSTRAINT "a_a_id_check" CHECK (a_id > 3) NO INHERIT;

CreateTableWithoutMultiColumnCheck:
  desired: |
    CREATE TABLE orders (
      id UUID NOT NULL PRIMARY KEY,
      order_number VARCHAR(255) NOT NULL,
      customer VARCHAR(255),
      store_table VARCHAR(255)
    );

AddMultiColumnCheck:
  current: |
    CREATE TABLE orders (
      id UUID NOT NULL PRIMARY KEY,
      order_number VARCHAR(255) NOT NULL,
      customer VARCHAR(255),
      store_table VARCHAR(255)
    );
  desired: |
    CREATE TABLE orders (
      id UUID NOT NULL PRIMARY KEY,
      order_number VARCHAR(255) NOT NULL,
      customer VARCHAR(255),
      store_table VARCHAR(255),
      CONSTRAINT check_customer_or_table CHECK (store_table is not null and customer is null or store_table is null and customer is not null)
    );
  output: |
    ALTER TABLE "public"."orders" ADD CONSTRAINT "check_customer_or_table" CHECK (store_table is not null and customer is null or store_table is null and customer is not null);

DropMultiColumnCheck:
  current: |
    CREATE TABLE orders (
      id UUID NOT NULL PRIMARY KEY,
      order_number VARCHAR(255) NOT NULL,
      customer VARCHAR(255),
      store_table VARCHAR(255),
      CONSTRAINT check_customer_or_table CHECK (store_table is not null and customer is null or store_table is null and customer is not null)
    );
  desired: |
    CREATE TABLE orders (
      id UUID NOT NULL PRIMARY KEY,
      order_number VARCHAR(255) NOT NULL,
      customer VARCHAR(255),
      store_table VARCHAR(255)
    );
  output: |
    ALTER TABLE "public"."orders" DROP CONSTRAINT "check_customer_or_table";

CreatePolicy:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY, name character varying(100));
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY, name character varying(100));
    CREATE POLICY p_users ON users AS PERMISSIVE FOR ALL TO PUBLIC USING (id = (current_user)::integer) WITH CHECK ((current_user)::integer = 1);
  output: |
    CREATE POLICY p_users ON users AS PERMISSIVE FOR ALL TO PUBLIC USING (id = (current_user)::integer) WITH CHECK ((current_user)::integer = 1);

ModifyPolicyToRestrictive:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY, name character varying(100));
    CREATE POLICY p_users ON users AS PERMISSIVE FOR ALL TO PUBLIC USING (id = (current_user)::integer) WITH CHECK ((current_user)::integer = 1);
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY, name character varying(100));
    CREATE POLICY p_users ON users AS RESTRICTIVE FOR ALL TO postgres USING (id = (current_user)::integer);
  output: |
    DROP POLICY "p_users" ON "public"."users";
    CREATE POLICY p_users ON users AS RESTRICTIVE FOR ALL TO postgres USING (id = (current_user)::integer);

ModifyPolicyUsing:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY, name character varying(100));
    CREATE POLICY p_users ON users AS RESTRICTIVE FOR ALL TO postgres USING (id = (current_user)::integer);
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY, name character varying(100));
    CREATE POLICY p_users ON users AS RESTRICTIVE FOR ALL TO postgres USING (true);
  output: |
    DROP POLICY "p_users" ON "public"."users";
    CREATE POLICY p_users ON users AS RESTRICTIVE FOR ALL TO postgres USING (true);

DropPolicy:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY, name character varying(100));
    CREATE POLICY p_users ON users AS RESTRICTIVE FOR ALL TO postgres USING (true);
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY, name character varying(100));
  output: |
    DROP POLICY "p_users" ON "public"."users";

AddUniqueConstraint:
  current: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
  desired: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b);
  output: |
    alter table dummy add constraint dummy_uniq unique (column_a, column_b);

UniqueConstraintNotDeferrable:
  current: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b);
  desired: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b) not deferrable initially immediate;
  output: ""

ModifyUniqueConstraintToDeferrable:
  current: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b) not deferrable initially immediate;
  desired: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b) deferrable;
  output: |
    ALTER TABLE "public"."dummy" DROP CONSTRAINT "dummy_uniq";
    alter table dummy add constraint dummy_uniq unique (column_a, column_b) deferrable;

ModifyUniqueConstraintToInitiallyDeferred:
  current: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b) deferrable;
  desired: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b) deferrable initially deferred;
  output: |
    ALTER TABLE "public"."dummy" DROP CONSTRAINT "dummy_uniq";
    alter table dummy add constraint dummy_uniq unique (column_a, column_b) deferrable initially deferred;

RevertUniqueConstraintToNotDeferrable:
  current: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b) deferrable initially deferred;
  desired: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b);
  output: |
    ALTER TABLE "public"."dummy" DROP CONSTRAINT "dummy_uniq";
    alter table dummy add constraint dummy_uniq unique (column_a, column_b);

DropUniqueConstraint:
  current: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
    alter table dummy add constraint dummy_uniq unique (column_a, column_b);
  desired: |
    create table dummy(
      column_a int not null,
      column_b int not null,
      column_c int not null
    );
  output: |
    ALTER TABLE "public"."dummy" DROP CONSTRAINT "dummy_uniq";

IndexOnReservedWordColumn:
  desired: |
    CREATE TABLE users (
      "key" text
    );
    CREATE INDEX "index_name" on users (key);

IndexWithOperatorClass:
  desired: |
    CREATE TABLE products (
      name VARCHAR(255)
    );
    CREATE INDEX product_name_autocomplete_index ON products(name text_pattern_ops);

IndexWithUsing:
  desired: |
    CREATE EXTENSION IF NOT EXISTS pg_trgm;
    CREATE TABLE products (
      id INTEGER PRIMARY KEY,
      name TEXT NOT NULL
    );
    CREATE INDEX idx_trgm_name ON products USING gin (name gin_trgm_ops);

CreateTypeEnum:
  desired: |
    CREATE TYPE "public"."country" AS ENUM ('us', 'jp');
    CREATE TABLE users (
      id SERIAL PRIMARY KEY,
      country "public"."country" NOT NULL DEFAULT 'jp'::country
    );

ColumnWithQuotes:
  desired: |
    CREATE TABLE users (
      "id" bigint NOT NULL,
      "name" text,
      "age" integer
    );

PostgreSQLDataTypes:
  desired: |
    CREATE TABLE users (
      c_array integer array,
      c_array_bracket integer[],
      c_bigint bigint,
      c_bigserial bigserial,
      c_bit bit,
      c_bit_2 bit(2),
      c_bool bool,
      c_boolean boolean,
      c_char_10 char(10),
      c_character_20 character(20),
      c_character_varying_30 character varying(30),
      c_date date,
      c_double_precision double precision,
      c_json json,
      c_jsonb jsonb,
      c_timestamp timestamp,
      c_timestamp_6 timestamp(6),
      c_timestamp_tz timestamp with time zone,
      c_timestamp_tz_6 timestamp(6) with time zone,
      c_timestamp_tz_6_notnull timestamp(6) with time zone not null,
      c_time time,
      c_time_6 time(6),
      c_time_tz time with time zone,
      c_time_tz_6 time(6) with time zone,
      c_time_tz_6_notnull time(6) with time zone not null,
      c_int int,
      c_integer integer,
      c_serial serial,
      c_text text,
      c_uuid uuid,
      c_varchar_40 varchar(40)
    );

CreateTableInNonPublicSchema:
  desired: |
    CREATE SCHEMA test;
    CREATE TABLE test.users (id serial primary key);
  output: |
    CREATE SCHEMA test;
    CREATE TABLE test.users (id serial primary key);

CheckConstraintInNonPublicSchema:
  current: |
    CREATE SCHEMA test;
    CREATE TABLE test.dummy (
      min_value INT CHECK (min_value > 0),
      max_value INT
    );
  desired: |
    CREATE TABLE test.dummy (
      min_value INT CHECK (min_value > 0),
      max_value INT CHECK (max_value > 0),
      CONSTRAINT min_max CHECK (min_value < max_value)
    );
  output: |
    ALTER TABLE "test"."dummy" ADD CONSTRAINT "dummy_max_value_check" CHECK (max_value > 0);
    ALTER TABLE "test"."dummy" ADD CONSTRAINT "min_max" CHECK (min_value < max_value);

RemoveCheckConstraintInNonPublicSchema:
  current: |
    CREATE SCHEMA test;
    CREATE TABLE test.dummy (
      min_value INT CHECK (min_value > 0),
      max_value INT CHECK (max_value > 0),
      CONSTRAINT min_max CHECK (min_value < max_value)
    );
  desired: |
    CREATE TABLE test.dummy (
      min_value INT CHECK (min_value > 0),
      max_value INT
    );
  output: |
    ALTER TABLE "test"."dummy" DROP CONSTRAINT "dummy_max_value_check";
    ALTER TABLE "test"."dummy" DROP CONSTRAINT "min_max";

SameTableNameAcrossSchemas:
  desired: |
    CREATE SCHEMA test;
    CREATE TABLE dummy (id int);
    CREATE TABLE test.dummy (id int);
  output: |
    CREATE SCHEMA test;
    CREATE TABLE dummy (id int);
    CREATE TABLE test.dummy (id int);

CreateTableWithIdentityAlways:
  desired: |
    CREATE TABLE color (
      color_id INT GENERATED ALWAYS AS IDENTITY,
      color_name VARCHAR NOT NULL
    );

AddIdentityToExistingColumn:
  current: |
    CREATE TABLE color (
      color_id INT NOT NULL,
      color_name VARCHAR NOT NULL
    );
  desired: |
    CREATE TABLE color (
      color_id INT GENERATED BY DEFAULT AS IDENTITY,
      color_name VARCHAR NOT NULL
    );
  output: |
    ALTER TABLE "public"."color" ALTER COLUMN "color_id" ADD GENERATED BY DEFAULT AS IDENTITY;

RemoveIdentityFromColumn:
  current: |
    CREATE TABLE color (
      color_id INT GENERATED BY DEFAULT AS IDENTITY,
      color_name VARCHAR NOT NULL
    );
  desired: |
    CREATE TABLE color (
      color_id INT NOT NULL,
      color_name VARCHAR NOT NULL
    );
  output: |
    ALTER TABLE "public"."color" ALTER COLUMN "color_id" DROP IDENTITY IF EXISTS;

ChangeIdentityFromByDefaultToAlways:
  current: |
    CREATE TABLE color (
      color_id INT GENERATED BY DEFAULT AS IDENTITY,
      color_name VARCHAR NOT NULL
    );
  desired: |
    CREATE TABLE color (
      color_id INT GENERATED ALWAYS AS IDENTITY,
      color_name VARCHAR NOT NULL
    );
  output: |
    ALTER TABLE "public"."color" ALTER COLUMN "color_id" SET GENERATED ALWAYS;

IdentityWithSequenceOptions:
  desired: |
    CREATE TABLE voltages (
      volt int GENERATED BY DEFAULT AS IDENTITY
        (START WITH -200 INCREMENT BY 10 MINVALUE -200 MAXVALUE 200)
    );

# Note: Sequence option changes are not supported, so this should result in no change
IdentitySequenceOptionsIgnored:
  current: |
    CREATE TABLE voltages (
      volt int GENERATED BY DEFAULT AS IDENTITY
        (START WITH -200 INCREMENT BY 10 MINVALUE -200 MAXVALUE 200)
    );
  desired: |
    CREATE TABLE voltages (
      volt int GENERATED BY DEFAULT AS IDENTITY
        (START WITH -100 INCREMENT BY 5 MINVALUE -100 MAXVALUE 100)
    );
  output: ""

AddIdentityWithSequenceToExistingColumn:
  current: |
    CREATE TABLE voltages (
      volt int
    );
  desired: |
    CREATE TABLE voltages (
      volt int GENERATED BY DEFAULT AS IDENTITY
        (START WITH -100 INCREMENT BY 5 MINVALUE -100 MAXVALUE 100)
    );
  output: |
    ALTER TABLE "public"."voltages" ALTER COLUMN "volt" SET NOT NULL;
    ALTER TABLE "public"."voltages" ALTER COLUMN "volt" ADD GENERATED BY DEFAULT AS IDENTITY (START WITH -100 INCREMENT BY 5 MINVALUE -100 MAXVALUE 100);

AddNewIdentityColumnWithSequence:
  current: |
    CREATE TABLE voltages (
      name varchar NOT NULL
    );
  desired: |
    CREATE TABLE voltages (
      name varchar NOT NULL,
      volt int GENERATED BY DEFAULT AS IDENTITY
        (START WITH -100 INCREMENT BY 5 MINVALUE -100 MAXVALUE 100)
    );
  output: |
    ALTER TABLE "public"."voltages" ADD COLUMN "volt" integer GENERATED BY DEFAULT AS IDENTITY (START WITH -100 INCREMENT BY 5 MINVALUE -100 MAXVALUE 100);

AddUniqueConstraintInNonPublicSchema:
  current: |
    CREATE SCHEMA test;
    CREATE TABLE test.dummy (a int, b int);
  desired: |
    CREATE TABLE test.dummy (a int, b int);
    ALTER TABLE test.dummy ADD CONSTRAINT a_b_uniq UNIQUE (a, b);
  output: |
    ALTER TABLE test.dummy ADD CONSTRAINT a_b_uniq UNIQUE (a, b);

ChangeUniqueConstraintInNonPublicSchema:
  current: |
    CREATE SCHEMA test;
    CREATE TABLE test.dummy (a int, b int);
    ALTER TABLE test.dummy ADD CONSTRAINT a_b_uniq UNIQUE (a, b);
  desired: |
    CREATE TABLE test.dummy (a int, b int);
    ALTER TABLE test.dummy ADD CONSTRAINT a_uniq UNIQUE (a) DEFERRABLE INITIALLY DEFERRED;
  output: |
    ALTER TABLE test.dummy ADD CONSTRAINT a_uniq UNIQUE (a) DEFERRABLE INITIALLY DEFERRED;
    ALTER TABLE "test"."dummy" DROP CONSTRAINT "a_b_uniq";

TableLevelCheckMultiColumnAllAny:
  desired: |
    CREATE TABLE multi_check_test (
      id INTEGER PRIMARY KEY,
      state TEXT NOT NULL,
      priority INTEGER NOT NULL,
      CONSTRAINT valid_state_priority CHECK (
        (state = ANY (ARRAY['active', 'pending']) AND priority >= ALL (ARRAY[1, 2])) OR
        (state = ALL (ARRAY['inactive']) AND priority = ANY (ARRAY[0]))
      )
    );

ModifyTableLevelCheckMultiColumnAllAny:
  current: |
    CREATE TABLE multi_check_test (
      id INTEGER PRIMARY KEY,
      state TEXT NOT NULL,
      priority INTEGER NOT NULL,
      CONSTRAINT valid_state_priority CHECK (
        (state = ANY (ARRAY['active', 'pending']) AND priority >= ALL (ARRAY[1, 2])) OR
        (state = ALL (ARRAY['inactive']) AND priority = ANY (ARRAY[0]))
      )
    );
  desired: |
    CREATE TABLE multi_check_test (
      id INTEGER PRIMARY KEY,
      state TEXT NOT NULL,
      priority INTEGER NOT NULL,
      CONSTRAINT valid_state_priority CHECK (
        (state = ANY (ARRAY['active', 'pending', 'waiting']) AND priority >= ALL (ARRAY[1, 2])) OR
        (state = ALL (ARRAY['inactive']) AND priority = ANY (ARRAY[0]))
      )
    );
  output: |
    ALTER TABLE "public"."multi_check_test" DROP CONSTRAINT "valid_state_priority";
    ALTER TABLE "public"."multi_check_test" ADD CONSTRAINT "valid_state_priority" CHECK (state = ANY (ARRAY['active', 'pending', 'waiting']) and priority >= ALL (ARRAY[1, 2]) or state = ALL (ARRAY['inactive']) and priority = ANY (ARRAY[0]));
DecimalDefault:
  current: |
    CREATE TABLE some_table (
      v0 decimal(5, 2) DEFAULT 0.0,
      v1 decimal(5, 2) DEFAULT 1.2,
      v2 decimal(30, 20) DEFAULT  0.12345,
      v3 decimal(30, 20) DEFAULT '0.0000000000123456789'
    );
  desired: |
    CREATE TABLE some_table (
      v0 decimal(5, 2) DEFAULT 0.01,
      v1 decimal(5, 2) DEFAULT 1.23,
      v2 decimal(30, 20) DEFAULT  0.1234,
      v3 decimal(30, 20) DEFAULT '0.00000000001234567891'
    );
  output: |
    ALTER TABLE "public"."some_table" ALTER COLUMN "v0" SET DEFAULT 0.010000;
    ALTER TABLE "public"."some_table" ALTER COLUMN "v1" SET DEFAULT 1.230000;
    ALTER TABLE "public"."some_table" ALTER COLUMN "v2" SET DEFAULT 0.123400;
    ALTER TABLE "public"."some_table" ALTER COLUMN "v3" SET DEFAULT '0.00000000001234567891';
NegativeDefaultNumbers:
  desired: |
    CREATE TABLE items (
      v0 float DEFAULT - 20,
      v1 float DEFAULT -3.14,
      v6 float DEFAULT -20,
      v7 decimal(5, 2) DEFAULT -20.0,
      v8 decimal(5, 2) DEFAULT 20.0,
      v9 decimal(5, 2) DEFAULT 0.0,
      v10 decimal(10, 4) DEFAULT 0.001,
      v11 decimal(10, 4) DEFAULT -0.001
    );
DefaultString:
  current: |
    CREATE TABLE some_table (
      v0 TEXT DEFAULT 'foo',
      v1 TEXT DEFAULT 'BAR'
    );
  desired: |
    CREATE TABLE some_table (
      v0 TEXT DEFAULT 'FOO',
      v1 TEXT DEFAULT 'bar'
    );
  output: |
    ALTER TABLE "public"."some_table" ALTER COLUMN "v0" SET DEFAULT 'FOO';
    ALTER TABLE "public"."some_table" ALTER COLUMN "v1" SET DEFAULT 'bar';
NumericDecimalVariablePrecision:
  current: |
    CREATE TABLE test (
      id int,
      num numeric,
      price decimal
    );
  desired: |
    CREATE TABLE test (
      id int,
      num numeric,
      price decimal
    );
  output: ""
NumericDecimalExplicit:
  current: |
    CREATE TABLE test (
      id int,
      num1 numeric(10),
      num2 numeric(15, 4),
      price1 decimal(12),
      price2 decimal(20, 6)
    );
  desired: |
    CREATE TABLE test (
      id int,
      num1 numeric(10),
      num2 numeric(15, 4),
      price1 decimal(12),
      price2 decimal(20, 6)
    );
  output: ""
AlterColumnSetDefault:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      status varchar(20),
      priority int
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      status varchar(20) DEFAULT 'active',
      priority int DEFAULT 1
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "status" SET DEFAULT 'active';
    ALTER TABLE "public"."users" ALTER COLUMN "priority" SET DEFAULT 1;

AlterColumnDropDefault:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      status varchar(20) DEFAULT 'active',
      priority int DEFAULT 1
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      status varchar(20),
      priority int
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "status" DROP DEFAULT;
    ALTER TABLE "public"."users" ALTER COLUMN "priority" DROP DEFAULT;

AlterColumnChangeDefault:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      status varchar(20) DEFAULT 'pending',
      is_active boolean DEFAULT false
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      status varchar(20) DEFAULT 'active',
      is_active boolean DEFAULT true
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "status" SET DEFAULT 'active';
    ALTER TABLE "public"."users" ALTER COLUMN "is_active" SET DEFAULT true;

AlterColumnSetNotNull:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name varchar(100),
      email varchar(255)
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name varchar(100) NOT NULL,
      email varchar(255) NOT NULL
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "name" SET NOT NULL;
    ALTER TABLE "public"."users" ALTER COLUMN "email" SET NOT NULL;

AlterColumnDropNotNull:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name varchar(100) NOT NULL,
      email varchar(255) NOT NULL
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name varchar(100),
      email varchar(255)
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "name" DROP NOT NULL;
    ALTER TABLE "public"."users" ALTER COLUMN "email" DROP NOT NULL;

AlterColumnChangeNotNullAndDefault:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name varchar(100),
      email varchar(255) NOT NULL DEFAULT 'unknown@example.com'
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name varchar(100) NOT NULL DEFAULT 'anonymous',
      email varchar(255)
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "name" SET NOT NULL;
    ALTER TABLE "public"."users" ALTER COLUMN "name" SET DEFAULT 'anonymous';
    ALTER TABLE "public"."users" ALTER COLUMN "email" DROP NOT NULL;
    ALTER TABLE "public"."users" ALTER COLUMN "email" DROP DEFAULT;
TypedLiterals:
  current: |
    CREATE TABLE events (
      id serial PRIMARY KEY
    );
  desired: |
    CREATE TABLE events (
      id serial PRIMARY KEY,
      event_date date DEFAULT DATE '2024-01-01',
      event_time time DEFAULT TIME '12:00:00',
      event_timestamp timestamp DEFAULT TIMESTAMP '2024-01-01 12:00:00'
    );
  output: |
    ALTER TABLE "public"."events" ADD COLUMN "event_date" date DEFAULT '2024-01-01';
    ALTER TABLE "public"."events" ADD COLUMN "event_time" time DEFAULT '12:00:00';
    ALTER TABLE "public"."events" ADD COLUMN "event_timestamp" timestamp DEFAULT '2024-01-01 12:00:00';
TypedLiteralsIdempotency:
  current: |
    CREATE TABLE events (
      id serial PRIMARY KEY,
      event_date date DEFAULT DATE '2024-01-01',
      event_time time DEFAULT TIME '12:00:00',
      event_timestamp timestamp DEFAULT TIMESTAMP '2024-01-01 12:00:00'
    );
  desired: |
    CREATE TABLE events (
      id serial PRIMARY KEY,
      event_date date DEFAULT DATE '2024-01-01',
      event_time time DEFAULT TIME '12:00:00',
      event_timestamp timestamp DEFAULT TIMESTAMP '2024-01-01 12:00:00'
    );
  output: ""
TypedLiteralsChangeDefault:
  current: |
    CREATE TABLE events (
      id serial PRIMARY KEY,
      event_date date DEFAULT DATE '2024-01-01',
      event_time time DEFAULT TIME '12:00:00',
      event_timestamp timestamp DEFAULT TIMESTAMP '2024-01-01 12:00:00'
    );
  desired: |
    CREATE TABLE events (
      id serial PRIMARY KEY,
      event_date date DEFAULT DATE '2024-12-31',
      event_time time DEFAULT TIME '23:59:59',
      event_timestamp timestamp DEFAULT TIMESTAMP '2024-12-31 23:59:59'
    );
  output: |
    ALTER TABLE "public"."events" ALTER COLUMN "event_date" SET DEFAULT '2024-12-31';
    ALTER TABLE "public"."events" ALTER COLUMN "event_time" SET DEFAULT '23:59:59';
    ALTER TABLE "public"."events" ALTER COLUMN "event_timestamp" SET DEFAULT '2024-12-31 23:59:59';
TypedLiteralsInCheckWithCast:
  current: |
    CREATE TABLE events (
      id serial PRIMARY KEY
    );
  desired: |
    CREATE TABLE events (
      id serial PRIMARY KEY,
      event_date date CHECK (event_date >= '2020-01-01'::date),
      event_time time CHECK (event_time >= time '09:00:00'),
      event_end_date date CHECK (event_end_date <= DATE '2030-12-31')
    );
  output: |
    ALTER TABLE "public"."events" ADD COLUMN "event_date" date CHECK (event_date >= '2020-01-01');
    ALTER TABLE "public"."events" ADD COLUMN "event_time" time CHECK (event_time >= '09:00:00'::time);
    ALTER TABLE "public"."events" ADD COLUMN "event_end_date" date CHECK (event_end_date <= '2030-12-31');

# Multi-dimensional array support
CreateTableWithMultiDimensionalArrays:
  desired: |
    CREATE TABLE matrices (
      id serial PRIMARY KEY,
      matrix_2d int[][],
      matrix_3d text[][][],
      coords double precision[][]
    );

AddMultiDimensionalArrayColumn:
  current: |
    CREATE TABLE matrices (
      id serial PRIMARY KEY
    );
  desired: |
    CREATE TABLE matrices (
      id serial PRIMARY KEY,
      matrix_2d int[][]
    );
  output: |
    ALTER TABLE "public"."matrices" ADD COLUMN "matrix_2d" integer[];

MultiDimensionalArrayWithDefaultEmpty:
  desired: |
    CREATE TABLE matrices (
      id serial PRIMARY KEY,
      matrix_2d int[][] DEFAULT ARRAY[]::int[],
      matrix_3d text[][][] DEFAULT ARRAY[]::text[]
    );

MultiDimensionalArrayWithNestedConstructor:
  desired: |
    CREATE TABLE matrices (
      id serial PRIMARY KEY,
      matrix_2d int[][] DEFAULT ARRAY[ARRAY[1, 2], ARRAY[3, 4]]
    );

ChangeMultiDimensionalArrayDefault:
  current: |
    CREATE TABLE matrices (
      id serial PRIMARY KEY,
      matrix_2d int[][] DEFAULT ARRAY[]::int[]
    );
  desired: |
    CREATE TABLE matrices (
      id serial PRIMARY KEY,
      matrix_2d int[][] DEFAULT ARRAY[ARRAY[1, 2]]
    );
  output: |
    ALTER TABLE "public"."matrices" ALTER COLUMN "matrix_2d" SET DEFAULT ARRAY[ARRAY[1, 2]];

# PostgreSQL treats int[], int[][], int[][][] all as int[] internally
MultiDimensionalArrayEquivalence1D2D:
  current: |
    CREATE TABLE test (
      arr int[]
    );
  desired: |
    CREATE TABLE test (
      arr int[][]
    );
  output: ""

MultiDimensionalArrayEquivalence2D3D:
  current: |
    CREATE TABLE test (
      arr int[][]
    );
  desired: |
    CREATE TABLE test (
      arr int[][][]
    );
  output: ""


# This ensures the parser handles storage parameters like fillfactor='70'
CreateIndexWithStorageParameterString:
  desired: |
    CREATE TABLE test_table (
      id serial,
      data text
    );
    CREATE INDEX idx_data ON test_table USING hash (data) WITH (fillfactor='70');

CreateIndexWithStorageParameterInt:
  desired: |
    CREATE TABLE test_table (
      id serial,
      data text
    );
    CREATE INDEX idx_data ON test_table USING btree (data) WITH (fillfactor=70);


CreateIndexWithUsingAndInclude:
  desired: |
    CREATE TABLE users (
      id serial,
      email text,
      name text,
      created_at timestamp
    );
    CREATE INDEX idx_email_include_name ON users USING btree (email) INCLUDE (name);

CreateIndexWithUsingIncludeWhere:
  desired: |
    CREATE TABLE orders (
      id serial,
      user_id int,
      status text,
      total numeric
    );
    CREATE INDEX idx_active_orders ON orders USING btree (user_id, status) INCLUDE (total) WHERE status = 'active';

CreateIndexWithMultipleStorageParameters:
  desired: |
    CREATE TABLE test_table (
      id serial,
      data text
    );
    CREATE INDEX idx_data_multi ON test_table USING btree (data) WITH (fillfactor='70', deduplicate_items='on');

CreateIndexWithOperatorClassAndWith:
  desired: |
    CREATE TABLE text_data (
      id serial,
      content text
    );
    CREATE INDEX idx_content_pattern ON text_data USING btree (content text_pattern_ops) WITH (fillfactor=90);

DefaultValueWithArrayTypeCast:
  desired: |
    CREATE TABLE settings (
      id serial,
      allowed_values text[] DEFAULT ARRAY['option1', 'option2']::text[]
    );

# Test for CREATE INDEX with string value for integer parameter
# PostgreSQL exports integer parameters as strings, ensure idempotency
CreateIndexWithStringifiedIntParameter:
  current: |
    CREATE TABLE test_table (
      id serial,
      data text
    );
    CREATE INDEX idx_data ON test_table USING btree (data) WITH (fillfactor=70);
  desired: |
    CREATE TABLE test_table (
      id serial,
      data text
    );
    CREATE INDEX idx_data ON test_table USING btree (data) WITH (fillfactor='70');
  output: ""


# Note: The parser can handle arbitrary storage parameter names (e.g., custom_param='value')
# but PostgreSQL itself validates and rejects unrecognized parameters at runtime.
# This is expected PostgreSQL behavior, not a parser limitation.

CreateIndexWithMultipleIncludeColumns:
  desired: |
    CREATE TABLE products (
      id serial,
      sku text,
      name text,
      price numeric,
      stock int
    );
    CREATE INDEX idx_sku_multi_include ON products USING btree (sku) INCLUDE (name, price, stock);

CreateIndexConcurrentlyWithUsingAndInclude:
  desired: |
    CREATE TABLE products (
      id serial,
      sku text,
      name text,
      price numeric
    );
    CREATE INDEX CONCURRENTLY idx_sku_include ON products USING btree (sku) INCLUDE (name, price);



# Test for CREATE INDEX with fillfactor parameter variations
# Ensures both integer and string values work and are treated as equivalent (main fix)
CreateIndexFillfactorVariations:
  current: |
    CREATE TABLE test_table (
      id serial,
      data text
    );
    CREATE INDEX idx1 ON test_table USING btree (data) WITH (fillfactor=70);
    CREATE INDEX idx2 ON test_table USING btree (id) WITH (fillfactor='80');
  desired: |
    CREATE TABLE test_table (
      id serial,
      data text
    );
    CREATE INDEX idx1 ON test_table USING btree (data) WITH (fillfactor='70');
    CREATE INDEX idx2 ON test_table USING btree (id) WITH (fillfactor=80);
  output: ""

CreateIndexUsingIncludeWhere:
  desired: |
    CREATE TABLE orders (
      id serial,
      user_id int,
      status text,
      total numeric
    );
    CREATE INDEX idx_orders_active ON orders USING btree (user_id, status)
      INCLUDE (total)
      WHERE status = 'active';

# Test for CREATE INDEX with generic storage parameter names
# Parser accepts any parameter name (PostgreSQL validates at runtime)
CreateIndexGenericStorageParameter:
  desired: |
    CREATE TABLE test_table (
      id serial,
      data text
    );
    CREATE INDEX idx_data ON test_table USING btree (data) WITH (deduplicate_items='on');
