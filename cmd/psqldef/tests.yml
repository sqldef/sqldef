CreateTable:
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
    CREATE TABLE bigdata (
      data bigint
    );
DropTable:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
    CREATE TABLE bigdata (
      data bigint
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  output: |
    DROP TABLE "public"."bigdata";
EmptyTable:
  desired: |
    CREATE TABLE public.test ();
CreateTableWithDefault:
  desired: |
    CREATE TABLE users (
      profile character varying(50) NOT NULL DEFAULT ''::character varying,
      default_int int default 20,
      default_bool bool default true,
      default_numeric numeric(5) default 42.195,
      default_fixed_char character(3) default 'JPN'::bpchar,
      default_text text default ''::text,
      default_json json default '[]'::json,
      default_jsonb jsonb default '[]'::jsonb,
      default_current_timestamp timestamp default CURRENT_TIMESTAMP,
      default_current_date date default CURRENT_DATE,
      default_current_time time default CURRENT_TIME,
      default_date_text text DEFAULT CURRENT_TIMESTAMP::date::text,
      default_now timestamp default now(),
      default_array_int int[] default '{}'::int[],
      default_array_constructor int[] DEFAULT ARRAY[]::int[],
      default_array_element_typecast text[] DEFAULT ARRAY[current_date::text]::text[],
      joined_at timestamp with time zone NOT NULL DEFAULT '0001-01-01 00:00:00'::timestamp without time zone,
      created_at timestamp with time zone DEFAULT now()
    );
CreateTableWithDefaultContainingQuote:
  current: |
    CREATE TABLE test ();
  desired: |
    CREATE TABLE test (
      thing text default 'it''s free real estate'
    );
  output: |
    ALTER TABLE "public"."test" ADD COLUMN "thing" text DEFAULT 'it''s free real estate';
CreateTableChangeDefaultBoolean:
  current: |
    CREATE TABLE test (
      col boolean default true
    );
  desired: |
    CREATE TABLE test (
      col boolean default false
    );
  output: |
    ALTER TABLE "public"."test" ALTER COLUMN "col" SET DEFAULT false;
CastBpchar:
  desired: |
    CREATE TABLE public.dummy_table (
      "col" character(30)
    );
    CREATE VIEW public.dummy_view AS SELECT dummy_table.col FROM dummy_table WHERE (dummy_table.col <> 'dummy value'::bpchar);
ParseTextCheckConstraint:
  current: |
    CREATE TABLE test (
      col text NOT NULL CHECK (col <> ''::text)
    );
  desired: |
    CREATE TABLE test (
      col text NOT NULL
    );
  output: |
    ALTER TABLE "public"."test" DROP CONSTRAINT test_col_check;
ParseAllAnyCheckConstraint:
  current: |
    CREATE TABLE test (
      n1 int,
      n2 int,
      t1 text
    );
  desired: |
    CREATE TABLE test (
      n1 int CHECK (n1 = ANY (ARRAY[1, 2, 3])),
      n2 int CHECK (n2 = ALL ('{1,2,3}'::int[])),
      t1 text CHECK (t1 = SOME ('{x,y}'::text[]))
    );
  output: |
    ALTER TABLE "public"."test" ADD CONSTRAINT test_n1_check CHECK (n1 = ANY (ARRAY[1, 2, 3]));
    ALTER TABLE "public"."test" ADD CONSTRAINT test_n2_check CHECK (n2 = ALL ('{1,2,3}'::integer[]));
    ALTER TABLE "public"."test" ADD CONSTRAINT test_t1_check CHECK (t1 = ANY ('{x,y}'::text[]));
NullCast:
  desired: |
    CREATE TABLE public.test (
      "item" character varying(16) DEFAULT NULL
    );
NumericCast:
  desired: |
    CREATE TABLE public.test_table (
      "item" numeric
    );
    CREATE VIEW public.test_view AS SELECT t.item FROM test_table t WHERE (t.item = (0)::numeric);
CreateIndexConcurrently:
  current: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128) DEFAULT 'konsumer'
    );
  desired: |
    CREATE TABLE users (
      id BIGINT NOT NULL PRIMARY KEY,
      name VARCHAR(128) DEFAULT 'konsumer'
    );
    CREATE INDEX CONCURRENTLY username on users (name);
  output: |
    CREATE INDEX CONCURRENTLY username on users (name);
CreateIndexWithCoalesce:
  current: |
    CREATE TABLE users (
      name TEXT,
      user_name TEXT
    );
  desired: |
    CREATE TABLE users (
      name TEXT,
      user_name TEXT
    );
    CREATE INDEX create_index_with_function_call ON users (name, COALESCE(user_name, 'NO_NAME'::TEXT));
  output: |
    CREATE INDEX create_index_with_function_call ON users (name, COALESCE(user_name, 'NO_NAME'::TEXT));
AlterTypeAddValue:
  current: |
    CREATE TYPE eventtype AS ENUM (
      'example',
      'send_message'
    );

    CREATE TABLE events (
      id UUID NOT NULL PRIMARY KEY,
      event_type eventtype NOT NULL
    );
  desired: |
    CREATE TYPE eventtype AS ENUM (
      'example',
      'send_message',
      'send_meeting_options',
      'update_reactionslot'
    );

    CREATE TABLE events (
      id UUID NOT NULL PRIMARY KEY,
      event_type eventtype NOT NULL
    );
  output: |
    ALTER TYPE public.eventtype ADD VALUE 'send_meeting_options';
    ALTER TYPE public.eventtype ADD VALUE 'update_reactionslot';
  min_version: '12'
AlterTypeAddValueWithSameTypeNameInDifferentSchema:
  current: |
    CREATE SCHEMA schema1;
    CREATE SCHEMA schema2;
    CREATE TYPE schema1.lang AS ENUM (
      'ja',
      'en'
    );
    CREATE TYPE schema2.lang AS ENUM (
      'ja',
      'en'
    );
  desired: |
    CREATE TYPE schema1.lang AS ENUM (
      'ja',
      'en'
    );
    CREATE TYPE schema2.lang AS ENUM (
      'ja',
      'en',
      'de'
    );
  output: |
    ALTER TYPE schema2.lang ADD VALUE 'de';
  min_version: '12'
UUIDCast:
  desired: |
    CREATE TABLE public.test_table (
      "id" uuid NOT NULL,
      "tenant_id" uuid NOT NULL,
      PRIMARY KEY ("id", "tenant_id")
    );
    CREATE POLICY tenant_isolation_policy ON test_table AS PERMISSIVE FOR ALL TO public
    USING (current_schema()::uuid = current_database()::uuid);
CreateIndexWithoutName:
  desired: |
    CREATE TABLE "user" (id BIGINT NOT NULL);
    CREATE INDEX ON "user" (id);
TypeColumn:
  desired: |
    CREATE TABLE "public"."test_table" (
      "id" bigint NOT NULL,
      "type" character varying(10)
    );
    CREATE VIEW public.test_view AS SELECT test_table.id, test_table."type" FROM test_table;
PosixRegexCheckConstraint:
  current: |
    CREATE TABLE test (
      posix_regex        text NOT NULL CHECK (posix_regex        ~   '[0-9]'),
      posix_regex_ci     text NOT NULL CHECK (posix_regex_ci     ~*  '[0-9]'),
      posix_not_regex    text NOT NULL CHECK (posix_not_regex    !~  '[0-9]'),
      posix_not_regex_ci text NOT NULL CHECK (posix_not_regex_ci !~* '[0-9]')
    );
  desired: |
    CREATE TABLE test (
      posix_regex        text NOT NULL CHECK (posix_regex        ~   '[a-z]'),
      posix_regex_ci     text NOT NULL CHECK (posix_regex_ci     ~*  '[a-z]'),
      posix_not_regex    text NOT NULL CHECK (posix_not_regex    !~  '[a-z]'),
      posix_not_regex_ci text NOT NULL CHECK (posix_not_regex_ci !~* '[a-z]')
    );
  output: |
    ALTER TABLE "public"."test" DROP CONSTRAINT test_posix_regex_check;
    ALTER TABLE "public"."test" ADD CONSTRAINT test_posix_regex_check CHECK (posix_regex ~ '[a-z]');
    ALTER TABLE "public"."test" DROP CONSTRAINT test_posix_regex_ci_check;
    ALTER TABLE "public"."test" ADD CONSTRAINT test_posix_regex_ci_check CHECK (posix_regex_ci ~* '[a-z]');
    ALTER TABLE "public"."test" DROP CONSTRAINT test_posix_not_regex_check;
    ALTER TABLE "public"."test" ADD CONSTRAINT test_posix_not_regex_check CHECK (posix_not_regex !~ '[a-z]');
    ALTER TABLE "public"."test" DROP CONSTRAINT test_posix_not_regex_ci_check;
    ALTER TABLE "public"."test" ADD CONSTRAINT test_posix_not_regex_ci_check CHECK (posix_not_regex_ci !~* '[a-z]');
IndexAndForeignOrder:
  desired: |
    CREATE TABLE posts (
      id bigint NOT NULL,
      user_id bigint NOT NULL,
      PRIMARY KEY ("id")
    );
    ALTER TABLE posts ADD CONSTRAINT "user_id_key" FOREIGN KEY ("user_id") REFERENCES users ("id");
    CREATE TABLE users (
      id bigint NOT NULL
    );
    CREATE UNIQUE INDEX uniq_idx ON users (id);
  output: |
    CREATE TABLE posts (
      id bigint NOT NULL,
      user_id bigint NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE users (
      id bigint NOT NULL
    );
    CREATE UNIQUE INDEX uniq_idx ON users (id);
    ALTER TABLE posts ADD CONSTRAINT "user_id_key" FOREIGN KEY ("user_id") REFERENCES users ("id");
ForeignKeyOnReservedName:
  current: |
    CREATE TABLE "public"."companies" (
      "id" character varying(100) NOT NULL,
      PRIMARY KEY ("id")
    );

    CREATE TABLE "public"."variables" (
      "id" character varying(100) NOT NULL,
      "company_id" character varying(100) NOT NULL,
      PRIMARY KEY ("id")
    );

    CREATE TABLE "public"."users" (
      "id" character varying(100) NOT NULL,
      "variable_id" character varying(100) NOT NULL,
      "name" character varying(100),
      PRIMARY KEY ("id")
    );
  desired: |
    CREATE TABLE IF NOT EXISTS companies (
      id VARCHAR(100) PRIMARY KEY
    );

    CREATE TABLE IF NOT EXISTS variables (
      id VARCHAR(100) PRIMARY KEY,
      company_id VARCHAR(100) NOT NULL REFERENCES companies(id)
    );

    CREATE TABLE IF NOT EXISTS users (
      id VARCHAR(100) PRIMARY KEY,
      variable_id VARCHAR(100) NOT NULL,
      name VARCHAR(100),
      CONSTRAINT users_variable_id_fk FOREIGN KEY (variable_id) REFERENCES variables(id)
    );
  output: |
    ALTER TABLE "public"."variables" ADD CONSTRAINT "variables_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies" ("id");
    ALTER TABLE "public"."users" ADD CONSTRAINT "users_variable_id_fk" FOREIGN KEY ("variable_id") REFERENCES "public"."variables" ("id");
NumericChangePrecisionAndScale:
  current: |
    CREATE TABLE test (
      num numeric (10, 3)
    );
  desired: |
    CREATE TABLE test (
      num numeric (10, 2)
    );
  output: |
    ALTER TABLE "public"."test" ALTER COLUMN "num" TYPE numeric(10, 2);
CheckConstraint:
  current: |
    CREATE TABLE test (
      n1 integer,
      n2 integer,
      n3 integer,
      t1 text,
      t2 text,
      t3 text,
      t4 varchar(10),
      d1 date,
      d2 date
    );
  desired: |
    CREATE TABLE test (
      n1 integer CHECK (n1 = 0 or not n1 > 10 and n1 IS NOT NULL),
      n2 integer CONSTRAINT chk CHECK (n2 > 0),
      n3 integer CHECK (n3 > 0) NO INHERIT,
      t1 text CHECK (t1 like 'x'),
      t2 text CHECK (t2 not like 'x'),
      t3 text CHECK (t3 <> ''::text),
      t4 varchar(10) CHECK (t4::text ~ '[0-9]'),
      d1 date CHECK (d1 >= '2022-01-01'::date),
      d2 date CHECK (d2 >= date '2022-01-01')
    );
  output: |
    ALTER TABLE "public"."test" ADD CONSTRAINT test_n1_check CHECK (n1 = 0 or not n1 > 10 and n1 is not null);
    ALTER TABLE "public"."test" ADD CONSTRAINT chk CHECK (n2 > 0);
    ALTER TABLE "public"."test" ADD CONSTRAINT test_n3_check CHECK (n3 > 0) NO INHERIT;
    ALTER TABLE "public"."test" ADD CONSTRAINT test_t1_check CHECK (t1 ~~ 'x');
    ALTER TABLE "public"."test" ADD CONSTRAINT test_t2_check CHECK (t2 !~~ 'x');
    ALTER TABLE "public"."test" ADD CONSTRAINT test_t3_check CHECK (t3 <> '');
    ALTER TABLE "public"."test" ADD CONSTRAINT test_t4_check CHECK (t4::text ~ '[0-9]');
    ALTER TABLE "public"."test" ADD CONSTRAINT test_d1_check CHECK (d1 >= '2022-01-01');
    ALTER TABLE "public"."test" ADD CONSTRAINT test_d2_check CHECK (d2 >= '2022-01-01');

CompositeForeignKeyConstraint:
  current: |
    CREATE TABLE t1 (
      id1 int not null,
      id2 int not null,
      PRIMARY KEY (id1, id2)
    );
    CREATE TABLE t2 (
      id1 int not null,
      id2 int not null,
      PRIMARY KEY (id1, id2)
    );
  desired: |
    CREATE TABLE t1 (
      id1 int not null,
      id2 int not null,
      PRIMARY KEY (id1, id2)
    );
    CREATE TABLE t2 (
      id1 int not null,
      id2 int not null,
      PRIMARY KEY (id1, id2),
      CONSTRAINT fk FOREIGN KEY (id1, id2) REFERENCES t1 (id1, id2)
    );
  output: |
    ALTER TABLE "public"."t2" ADD CONSTRAINT "fk" FOREIGN KEY ("id1","id2") REFERENCES "public"."t1" ("id1","id2");
MaterializedView:
  desired: |
    CREATE TABLE points (id bigint);
    CREATE MATERIALIZED VIEW IF NOT EXISTS points_view AS SELECT id FROM points;
CreateMaterializedView:
  current: |
    CREATE TABLE public.users (
      id BIGINT PRIMARY KEY,
      name character varying(100)
    );
    CREATE TABLE public.posts (
      id BIGINT PRIMARY KEY,
      name character varying(100),
      user_id BIGINT,
      is_deleted boolean
    );
  desired: |
    CREATE TABLE public.users (
      id BIGINT PRIMARY KEY,
      name character varying(100)
    );
    CREATE TABLE public.posts (
      id BIGINT PRIMARY KEY,
      name character varying(100),
      user_id BIGINT,
      is_deleted boolean
    );
    CREATE MATERIALIZED VIEW public.view_user_posts AS SELECT p.id FROM (posts as p JOIN users as u ON ((p.user_id = u.id)));
  output: |
    CREATE MATERIALIZED VIEW public.view_user_posts AS SELECT p.id FROM (posts as p JOIN users as u ON ((p.user_id = u.id)));
DropMaterializedView:
  current: |
    CREATE TABLE "public"."points" (id bigint);
    CREATE MATERIALIZED VIEW IF NOT EXISTS "public"."points_view" AS SELECT id FROM points;
  desired: |
    CREATE TABLE "public"."points" (id bigint);
  output: |
    DROP MATERIALIZED VIEW "public"."points_view";
IntervalExpression:
  desired: |
    CREATE TABLE points (id bigint, created_at timestamp, main_type text, sub_type text, user_id bigint);
    CREATE MATERIALIZED VIEW IF NOT EXISTS points_view AS
    SELECT * FROM points
    WHERE id IN (
      SELECT MAX(id) AS id
      FROM points
      WHERE to_timestamp(concat(to_char(current_date - INTERVAL '1 YEAR' + INTERVAL '1 DAY', 'YYYY-MM-DD'), ' 00:00:00'), 'YYYY-MM-DD HH24:MI:SS') < created_at
      AND created_at <= to_timestamp(concat(to_char(current_date, 'YYYY-MM-DD'), ' 23:59:59'), 'YYYY-MM-DD HH24:MI:SS')
      GROUP BY main_type, sub_type, user_id
    );
IntervalType:
  desired: |
    CREATE TABLE public.test (
      col interval
    );
MaterializedViewIndex:
  desired: |
    CREATE TABLE IF NOT EXISTS points (
        id          BIGINT        PRIMARY KEY,
        tenant_id   BIGINT        NOT NULL,
        user_id     VARCHAR(100)  NOT NULL,
        point_type  SMALLINT      NOT NULL,
        point_value SMALLINT      NOT NULL,
        created_at  TIMESTAMP     NOT NULL,
        updated_at  TIMESTAMP     NOT NULL
    );
    CREATE INDEX points_idx ON points (tenant_id, user_id, point_type);
    CREATE MATERIALIZED VIEW IF NOT EXISTS points_view AS
        SELECT * FROM points
        WHERE id IN (SELECT MAX(id) AS id
            FROM points
            GROUP BY point_type, user_id);
    CREATE INDEX points_view_idx ON points_view (tenant_id);
  output: |
    CREATE TABLE IF NOT EXISTS points (
        id          BIGINT        PRIMARY KEY,
        tenant_id   BIGINT        NOT NULL,
        user_id     VARCHAR(100)  NOT NULL,
        point_type  SMALLINT      NOT NULL,
        point_value SMALLINT      NOT NULL,
        created_at  TIMESTAMP     NOT NULL,
        updated_at  TIMESTAMP     NOT NULL
    );
    CREATE MATERIALIZED VIEW IF NOT EXISTS points_view AS
        SELECT * FROM points
        WHERE id IN (SELECT MAX(id) AS id
            FROM points
            GROUP BY point_type, user_id);
    CREATE INDEX points_idx ON points (tenant_id, user_id, point_type);
    CREATE INDEX points_view_idx ON points_view (tenant_id);
Comment:
  current: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      "foo" text NOT NULL DEFAULT ''::text,
      PRIMARY KEY ("id")
    );
  desired: |
    CREATE TABLE "public"."hoge" (
        "id" bigserial NOT NULL,
        "foo" text NOT NULL DEFAULT ''::text,
        PRIMARY KEY ("id")
    );

    COMMENT ON TABLE public.hoge is 'hoge table';
    COMMENT ON COLUMN public.hoge.id is 'hoge id';
    COMMENT ON COLUMN public.hoge.foo is 'foo comment';
  output: |
    COMMENT ON TABLE public.hoge is 'hoge table';
    COMMENT ON COLUMN public.hoge.id is 'hoge id';
    COMMENT ON COLUMN public.hoge.foo is 'foo comment';
MultipleComments:
  current: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "public"."bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON COLUMN public.hoge.id is 'hoge id';
  desired: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "public"."bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON COLUMN public.hoge.id is 'hoge id';
    COMMENT ON COLUMN public.bar.id is 'bar id';
  output: |
    COMMENT ON COLUMN public.bar.id is 'bar id';
UpdateComment:
  current: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "public"."bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON TABLE public.hoge is 'hoge table';
    COMMENT ON COLUMN public.hoge.id is 'hoge id';
    COMMENT ON TABLE public.bar is 'bar table';
    COMMENT ON COLUMN public.bar.id is 'bar id';
  desired: |
    CREATE TABLE "public"."hoge" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );
    CREATE TABLE "public"."bar" (
      "id" bigserial NOT NULL,
      PRIMARY KEY ("id")
    );

    COMMENT ON TABLE public.hoge is 'hoge table updated';
    COMMENT ON COLUMN public.hoge.id is 'hoge id updated';
    COMMENT ON TABLE public.bar is 'bar table';
    COMMENT ON COLUMN public.bar.id is 'bar id';
  output: |
    COMMENT ON TABLE public.hoge is 'hoge table updated';
    COMMENT ON COLUMN public.hoge.id is 'hoge id updated';
CommentOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE foo.users (
      id bigint
    );
  desired: |
    CREATE TABLE foo.users (
      id bigint
    );
    COMMENT ON TABLE foo.users is 'users table updated';
    COMMENT ON COLUMN foo.users.id is 'users id';
  output: |
    COMMENT ON TABLE foo.users is 'users table updated';
    COMMENT ON COLUMN foo.users.id is 'users id';
  user: psqldef_user
CommentContainingQuote:
  current: |
    CREATE TABLE public.test (
      email text
    );
  desired: |
    CREATE TABLE public.test (
      email text
    );
    COMMENT ON TABLE public.test is 'World''s best table';
    COMMENT ON COLUMN public.test.email is 'The user''s contact email address.';
  output: |
    COMMENT ON TABLE public.test is 'World''s best table';
    COMMENT ON COLUMN public.test.email is 'The user''s contact email address.';
CreateViewCast:
  current: |
    CREATE TABLE "public"."hoge" (
      "amount" text
    );
    CREATE VIEW public.hoge_view AS SELECT (hoge.amount)::numeric(10,2) AS amount_num FROM hoge;
  desired: |
    create table hoge (
      amount text
    );

    create view hoge_view as
    select
      amount::numeric(10,2) as amount_num
    from hoge;
  output: ''
ReplaceViewWithChangeCondition:
  current: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );

    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge
      WHERE bar = 'baz';
  output: |
    CREATE OR REPLACE VIEW "public"."v" AS select foo, bar from hoge where bar = 'baz';
ReplaceViewWithAddColumnToTail:
  current: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );

    CREATE VIEW v AS
    SELECT
      foo,
      bar,
      'x' as added
     FROM hoge;
  output: |
    CREATE OR REPLACE VIEW "public"."v" AS select foo, bar, 'x' as added from hoge;
ReplaceViewWithAddColumnToMiddle:
  current: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );

    CREATE VIEW v AS
    SELECT
      foo,
      'x' as added,
      bar
     FROM hoge;
  output: |
    DROP VIEW "public"."v";
    CREATE VIEW "public"."v" AS select foo, 'x' as added, bar from hoge;
ReplaceViewWithDropColumn:
  current: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );

    CREATE VIEW v AS
    SELECT foo FROM hoge;
  output: |
    DROP VIEW "public"."v";
    CREATE VIEW "public"."v" AS select foo from hoge;
ReplaceViewWithChangeColumn:
  current: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE "public"."hoge" (
      "foo" text,
      "bar" text
    );

    CREATE VIEW v AS
    SELECT
      foo,
      'x' as changed
    FROM hoge;
  output: |
    DROP VIEW "public"."v";
    CREATE VIEW "public"."v" AS select foo, 'x' as changed from hoge;
CreateExtension:
  current: |
    CREATE EXTENSION pgcrypto;
  desired: |
    CREATE EXTENSION pgcrypto;
    CREATE EXTENSION btree_gist;
  output: |
    CREATE EXTENSION btree_gist;
DropExtension:
  current: |
    CREATE EXTENSION pgcrypto;
    CREATE EXTENSION btree_gist;
  desired:
    CREATE EXTENSION btree_gist;
  output: |
    DROP EXTENSION "pgcrypto";
CreateExtensionIfNotExists:
  desired: |
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
  output: |
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
CreateExtensionOrder:
  desired: |
    CREATE TABLE hoge (id UUID DEFAULT gen_random_uuid());
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
  output: |
    CREATE EXTENSION IF NOT EXISTS pgcrypto;
    CREATE TABLE hoge (id UUID DEFAULT gen_random_uuid());
CreateViewWithCastCase:
  desired: |
    create table hoge (amount text);
    create view hoge_view as
    select
      '1'::numeric as n,
      ''::text as t,
      2::bigint as i,
      amount::numeric(10,2) as amount_num
    from hoge;
CreateViewWithCaseWhen:
  desired: |
    create table hoge (
      amount  text,
      hoge_type text,
      payload jsonb
    );
    create view hoge_view as
    select
      -- pattern 1
      amount::numeric(10,2) as amount_num1,
      -- pattern 2
      (
        jsonb_extract_path_text(payload, 'amount')
      )::numeric(10,2) as amount_num2,
      -- pattern 3
      (
        case hoge_type
          when 'hoge' then jsonb_extract_path_text(payload, 'hoge', 'amount')
        end
      )::numeric(10,2) as amount_num3,
      -- pattern 4
      (
        to_timestamp(
          jsonb_extract_path_text(payload, 'created')::bigint
        )
      ) as created,
      -- pattern 5
      (
        cast(
          to_timestamp(
            jsonb_extract_path_text(payload, 'created')::bigint
          ) as date
        )
      ) as created_date
    from hoge;
CreateViewWithoutFrom:
  desired: |
    create view v as select 10 as n;
CreateTableAlterColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name varchar(40)
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "name" TYPE varchar(40);
CreateTableAddColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "age" integer;
CreateTableDropColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      age integer
    );
  output: |
    ALTER TABLE "public"."users" DROP COLUMN "name";
IndexesOnExpressions:
  current: |
    CREATE TABLE public.test (
      col JSONB
    );
  desired: |
    CREATE TABLE public.test (
      col JSONB
    );
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo', 'bar'));
  output: |
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo', 'bar'));
IndexesOnChangedExpressions:
  current: |
    CREATE TABLE public.test (
      col JSONB
    );
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo', 'bar'));
  desired: |
    CREATE TABLE public.test (
      col JSONB
    );
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo'));
  output: |
    DROP INDEX "public"."function_index";
    CREATE UNIQUE INDEX function_index ON public.test (jsonb_extract_path_text(col, 'foo'));
EscapeUniqueIndexQuery:
  current: |
    CREATE TABLE "userTable" (
        id uuid NOT NULL,
        "firstName" text,
        "lastName" text
    );
  desired: |
    CREATE TABLE "userTable" (
        id uuid NOT NULL,
        "firstName" text,
        "lastName" text
    );
    ALTER TABLE "public"."userTable" ADD CONSTRAINT "uq:fullName" UNIQUE ("firstName", "lastName");
  output: |
    ALTER TABLE "public"."userTable" ADD CONSTRAINT "uq:fullName" UNIQUE ("firstName", "lastName");
AddArrayColumn:
  current: |
    CREATE TABLE users (
      id integer
    );
  desired: |
    CREATE TABLE users (
      id integer,
      name integer[]
    );
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "name" integer[];
AddForeignKeyWithAlter:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE CASCADE;
  output: |
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE CASCADE;
AddDifferentForeignKeyWithSameName:
  current: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL ON UPDATE CASCADE;
  desired: |
    CREATE TABLE users (id BIGINT PRIMARY KEY);
    CREATE TABLE posts (
      content text,
      user_id bigint
    );
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON UPDATE CASCADE;
  output: |
    ALTER TABLE "public"."posts" DROP CONSTRAINT "posts_ibfk_1";
    ALTER TABLE ONLY public.posts ADD CONSTRAINT posts_ibfk_1 FOREIGN KEY (user_id) REFERENCES users (id) ON UPDATE CASCADE;
CreateTableOnNonStandardDefaultSchema:
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
    CREATE TABLE bigdata (
      data bigint
    );
  user: psqldef_user
DropTableOnNonStandardDefaultSchema:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
    CREATE TABLE bigdata (
      data bigint
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  output: |
    DROP TABLE "foo"."bigdata";
  user: psqldef_user
ChangeTimezone:
  current: |
    CREATE TABLE test (
      timestamp_at1 timestamp with time zone NOT NULL,
      timestamp_at2 timestamp with time zone NOT NULL,
      timestamp_at3 timestamp NOT NULL,
      timestamp_at4 timestamp WITHOUT TIME ZONE NOT NULL,
      time_at1 time WITH TIME ZONE NOT NULL,
      time_at2 time WITH TIME ZONE NOT NULL,
      time_at3 time NOT NULL,
      time_at4 time WITHOUT TIME ZONE NOT NULL
    );
  desired: |
    CREATE TABLE test (
      timestamp_at1 timestamp WITHOUT TIME ZONE NOT NULL,
      timestamp_at2 timestamp NOT NULL,
      timestamp_at3 timestamp WITH TIME ZONE NOT NULL,
      timestamp_at4 timestamp WITH TIME ZONE NOT NULL,
      time_at1 time WITHOUT TIME ZONE NOT NULL,
      time_at2 time NOT NULL,
      time_at3 time WITH TIME ZONE NOT NULL,
      time_at4 time WITH TIME ZONE NOT NULL
    );
  output: |
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_at1" TYPE timestamp;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_at2" TYPE timestamp;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_at3" TYPE timestamp WITH TIME ZONE;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_at4" TYPE timestamp WITH TIME ZONE;
    ALTER TABLE "public"."test" ALTER COLUMN "time_at1" TYPE time;
    ALTER TABLE "public"."test" ALTER COLUMN "time_at2" TYPE time;
    ALTER TABLE "public"."test" ALTER COLUMN "time_at3" TYPE time WITH TIME ZONE;
    ALTER TABLE "public"."test" ALTER COLUMN "time_at4" TYPE time WITH TIME ZONE;
ChangeTimezoneSyntax:
  current: |
    CREATE TABLE test (
      timestamp_wtz_wtz     timestamp with time zone,
      timestamp_wtz_tz      timestamp with time zone,
      timestamp_wtz_plain   timestamp with time zone,
      timestamp_tz_wtz      timestamptz,
      timestamp_tz_tz       timestamptz,
      timestamp_tz_plain    timestamptz,
      timestamp_plain_wtz   timestamp,
      timestamp_plain_tz    timestamp,
      timestamp_plain_plain timestamp
    );
  desired: |
    CREATE TABLE test (
      timestamp_wtz_wtz     timestamp with time zone,
      timestamp_wtz_tz      timestamptz,
      timestamp_wtz_plain   timestamp,
      timestamp_tz_wtz      timestamp with time zone,
      timestamp_tz_tz       timestamptz,
      timestamp_tz_plain    timestamp,
      timestamp_plain_wtz   timestamp with time zone,
      timestamp_plain_tz    timestamptz,
      timestamp_plain_plain timestamp
    );
  output: |
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_wtz_plain" TYPE timestamp;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_tz_plain" TYPE timestamp;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_plain_wtz" TYPE timestamp WITH TIME ZONE;
    ALTER TABLE "public"."test" ALTER COLUMN "timestamp_plain_tz" TYPE timestamp WITH TIME ZONE;
CreateTableAddTimestampColumn:
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer
    );
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text,
      age integer,
      timestamp_with_tz timestamp WITH TIME ZONE,
      timestamp_without_tz timestamp WITHOUT TIME ZONE
    );
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "timestamp_with_tz" timestamp WITH TIME ZONE;
    ALTER TABLE "public"."users" ADD COLUMN "timestamp_without_tz" timestamp;
AddColumnWithDefaultExpression:
  current: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (id bigint NOT NULL);
  desired: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL DEFAULT uuid_generate_v4()
    );
  output: |
    ALTER TABLE "public"."users" ADD COLUMN "key" uuid NOT NULL DEFAULT uuid_generate_v4();
AddDefaultExpression:
  current: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL
    );
  desired: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL DEFAULT uuid_generate_v4()
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "key" SET DEFAULT uuid_generate_v4();
RemoveDefaultExpression:
  current: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL DEFAULT uuid_generate_v4()
    );
  desired: |
    CREATE EXTENSION "uuid-ossp";
    CREATE TABLE users (
      id bigint NOT NULL,
      "key" uuid NOT NULL
    );
  output: |
    ALTER TABLE "public"."users" ALTER COLUMN "key" DROP DEFAULT;
ChangeDefaultExpressionWithAddition:
  current: |
    CREATE TABLE public.foo (
      expires_at timestamp with time zone NOT NULL DEFAULT (CURRENT_TIMESTAMP + '1 day'::interval)
    );
  desired: |
    CREATE TABLE public.foo (
      expires_at timestamp with time zone NOT NULL DEFAULT (CURRENT_TIMESTAMP + '3 days'::interval)
    );
  output: |
    ALTER TABLE "public"."foo" ALTER COLUMN "expires_at" SET DEFAULT current_timestamp + '3 days'::interval;
CreateTableAddAbsentForeignKey:
  current: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE posts (
      content TEXT,
      user_id INT
    );
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE posts (
      content TEXT,
      user_id INT REFERENCES users(id)
    );
  output: |
    ALTER TABLE "public"."posts" ADD CONSTRAINT "posts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users" ("id");
CreateTableWithConstraintOptions:
  current: |
    CREATE TABLE images (
      id INT PRIMARY KEY
    );
    CREATE TABLE image_owners (
      id INT,
      type VARCHAR(20) NOT NULL,
      PRIMARY KEY (type, id)
    );
    CREATE TABLE image_bindings (
      image_id INT REFERENCES images(id) ON DELETE CASCADE,
      image_order INT NOT NULL,
      image_owner_type VARCHAR(20) NOT NULL,
      image_owner_id INT NOT NULL,
      CONSTRAINT image_owner_fk FOREIGN KEY (image_owner_type, image_owner_id) REFERENCES image_owners(type, id) ON DELETE CASCADE,
      CONSTRAINT image_order_unique UNIQUE (image_owner_type, image_owner_id, image_order)
    );
  desired: |
    CREATE TABLE images (
      id INT PRIMARY KEY
    );
    CREATE TABLE image_owners (
      id INT,
      type VARCHAR(20) NOT NULL,
      PRIMARY KEY (type, id)
    );
    CREATE TABLE image_bindings (
      image_id INT REFERENCES images(id) ON DELETE CASCADE DEFERRABLE INITIALLY IMMEDIATE,
      image_order INT NOT NULL,
      image_owner_type VARCHAR(20) NOT NULL,
      image_owner_id INT NOT NULL,
      CONSTRAINT image_owner_fk FOREIGN KEY (image_owner_type, image_owner_id) REFERENCES image_owners(type, id) ON DELETE CASCADE DEFERRABLE INITIALLY IMMEDIATE,
      CONSTRAINT image_order_unique UNIQUE (image_owner_type, image_owner_id, image_order) DEFERRABLE INITIALLY DEFERRED
    );
  output: |
    ALTER TABLE "public"."image_bindings" DROP CONSTRAINT "image_order_unique";
    ALTER TABLE "public"."image_bindings" ADD CONSTRAINT "image_order_unique" UNIQUE ("image_owner_type", "image_owner_id", "image_order") DEFERRABLE INITIALLY DEFERRED;
    ALTER TABLE "public"."image_bindings" DROP CONSTRAINT "image_bindings_image_id_fkey";
    ALTER TABLE "public"."image_bindings" ADD CONSTRAINT "image_bindings_image_id_fkey" FOREIGN KEY ("image_id") REFERENCES "public"."images" ("id") ON DELETE CASCADE DEFERRABLE INITIALLY IMMEDIATE;
    ALTER TABLE "public"."image_bindings" DROP CONSTRAINT "image_owner_fk";
    ALTER TABLE "public"."image_bindings" ADD CONSTRAINT "image_owner_fk" FOREIGN KEY ("image_owner_type","image_owner_id") REFERENCES "public"."image_owners" ("type","id") ON DELETE CASCADE DEFERRABLE INITIALLY IMMEDIATE;
CreateTableWithForeignKeyAndGeneratedColumn:
  min_version: '12'
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE emails (
      user_id INT NOT NULL,
      local_part VARCHAR(100) NOT NULL,
      domain VARCHAR(100) NOT NULL,
      lower_address TEXT GENERATED ALWAYS AS (LOWER(local_part || '@' || domain)) STORED NOT NULL,
      PRIMARY KEY (domain, local_part),
      CONSTRAINT user_fk FOREIGN KEY (user_id) REFERENCES users(id)
    );
ViewWithNullableColumn:
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY,
      name TEXT NULL,
      deleted BOOLEAN NOT NULL
    );
    CREATE VIEW active_users AS
    SELECT id, name FROM users WHERE NOT deleted;
CaseWithoutArgument:
  desired: |
    CREATE TABLE permissions (
      name TEXT NOT NULL,
      admin BOOLEAN NOT NULL,
      CONSTRAINT admin_name CHECK (
        CASE
          WHEN admin THEN name LIKE 'admin%'
          ELSE true
        END
      )
    );
ViewWithDistinct:
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE taggings (
      user_id INT NOT NULL REFERENCES users(id),
      tag TEXT NOT NULL
    );
    CREATE VIEW tags AS
    SELECT DISTINCT tag FROM taggings;
ViewWithGroupByAndHaving:
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE taggings (
      user_id INT NOT NULL REFERENCES users(id),
      tag TEXT NOT NULL
    );
    CREATE VIEW tag_counts AS
    SELECT tag, COUNT(*) AS count
    FROM taggings GROUP BY tag HAVING COUNT(*) > 1;
LongAutoGeneratedForeignKeyConstraint:
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE loooooooooooooooooooooooooooooooooooooooong_table_63_characters (
      -- loooooooooooooooooooooooooooooooooooooooong_table_63_cha_a_fkey
      a INT NOT NULL REFERENCES users (id)
    );
    CREATE TABLE loooooong_table_29_characters (
      -- loooooong_table_29_characters_loooong_column_28_characters_fkey
      loooong_column_28_characters INT NOT NULL REFERENCES users (id),

      -- loooooong_table_29_characters_looooong_column_29_character_fkey
      looooong_column_29_characters INT NOT NULL REFERENCES users (id)
    );
    CREATE TABLE looooooong_table_30_characters (
      -- looooooong_table_30_character_looooong_column_29_character_fkey
      looooong_column_29_characters INT NOT NULL REFERENCES users (id),

      -- looooooong_table_30_character_loooong_column_28_characters_fkey
      loooong_column_28_characters INT NOT NULL REFERENCES users (id),

      -- looooooong_table_30_characters_looong_column_27_characters_fkey
      looong_column_27_characters INT NOT NULL REFERENCES users (id)
    );
    CREATE TABLE a (
      -- a_looooooooooooooooooooooooooooooooong_column_57_character_fkey
      looooooooooooooooooooooooooooooooong_column_57_characters INT NOT NULL REFERENCES users (id),

      -- a_loooooooooooooooooooooooooooooooong_column_56_characters_fkey
      loooooooooooooooooooooooooooooooong_column_56_characters INT NOT NULL REFERENCES users (id)
    );
LongAutoGeneratedCheckConstraint:
  desired: |
    CREATE TABLE loooooooooooooooooooooooooooooooooooooooong_table_63_characters (
      -- loooooooooooooooooooooooooooooooooooooooong_table_63_ch_a_check
      a INT NOT NULL CHECK (a > 0)
    );
    CREATE TABLE loooooong_table_29_characters (
      -- loooooong_table_29_characters_looong_column_27_characters_check
      looong_column_27_characters INT NOT NULL CHECK (looong_column_27_characters > 0),

      -- loooooong_table_29_characters_loooong_column_28_character_check
      loooong_column_28_characters INT NOT NULL CHECK (loooong_column_28_characters > 0),

      -- loooooong_table_29_character_looooong_column_29_character_check
      looooong_column_29_characters INT NOT NULL CHECK (looooong_column_29_characters > 0)
    );
    CREATE TABLE looooooong_table_30_characters (
      -- looooooong_table_30_characters_loong_column_26_characters_check
      loong_column_26_characters INT NOT NULL CHECK (loong_column_26_characters > 0),

      -- looooooong_table_30_character_looong_column_27_characters_check
      looong_column_27_characters INT NOT NULL CHECK (looong_column_27_characters > 0),

      -- looooooong_table_30_characte_loooong_column_28_characters_check
      loooong_column_28_characters INT NOT NULL CHECK (loooong_column_28_characters > 0)
    );
    CREATE TABLE a (
      -- a_loooooooooooooooooooooooooooooooong_column_56_character_check
      loooooooooooooooooooooooooooooooong_column_56_characters INT NOT NULL CHECK (loooooooooooooooooooooooooooooooong_column_56_characters > 0),

      -- a_looooooooooooooooooooooooooooooong_column_55_characters_check
      looooooooooooooooooooooooooooooong_column_55_characters INT NOT NULL CHECK (looooooooooooooooooooooooooooooong_column_55_characters > 0)
    );
CreateSchema:
  desired: |
    CREATE TABLE foo.test (id int);
    CREATE SCHEMA foo;
    CREATE SCHEMA IF NOT EXISTS bar;
  output: |
    CREATE SCHEMA foo;
    CREATE SCHEMA IF NOT EXISTS bar;
    CREATE TABLE foo.test (id int);
