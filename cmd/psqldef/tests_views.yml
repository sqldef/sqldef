# yaml-language-server: $schema=../../testutil/testcase.schema.json

View:
  desired: |
    CREATE TABLE points (id bigint);
    CREATE VIEW points_view AS SELECT id FROM points;

# PostgreSQL expands SELECT * to explicit column names when storing view definitions.
# This test verifies that views with SELECT * are correctly compared and don't cause
# unnecessary view recreation.
ViewWithSelectStar:
  legacy_ignore_quotes: false
  desired: |
    CREATE TABLE users (id integer, name text);
    CREATE VIEW users_view AS SELECT * FROM users;

MaterializedView:
  desired: |
    CREATE TABLE points (id bigint);
    CREATE MATERIALIZED VIEW points_view AS SELECT id FROM points;
MaterializedViewWithData:
  desired: |
    CREATE TABLE points (id bigint);
    CREATE MATERIALIZED VIEW points_view AS SELECT id FROM points WITH DATA;
MaterializedViewWithNoData:
  desired: |
    CREATE TABLE points (id bigint);
    CREATE MATERIALIZED VIEW points_view AS SELECT id FROM points WITH NO DATA;

ViewDDLsAreEmittedLastWithoutChangingDefinition:
  current: |
    CREATE TABLE foos (
      id bigint PRIMARY KEY
    );
  desired: |
    CREATE VIEW foos_view AS SELECT id, secret FROM foos WHERE secret = false;
    CREATE TABLE foos (
      id bigint PRIMARY KEY,
      secret boolean NOT NULL DEFAULT false
    );
  up: |
    ALTER TABLE "foos" ADD COLUMN "secret" boolean NOT NULL DEFAULT false;
    CREATE VIEW foos_view AS SELECT id, secret FROM foos WHERE secret = false;
  down: |
    DROP VIEW "foos_view";
    ALTER TABLE "foos" DROP COLUMN "secret";
ViewDDLsAreEmittedLastWithChangingDefinition:
  current: |
    CREATE TABLE foos (
      id bigint PRIMARY KEY
    );
    CREATE VIEW foos_view AS SELECT 1 AS dummy;
  desired: |
    CREATE VIEW foos_view AS
      SELECT id, secret FROM foos WHERE secret = false;
    CREATE TABLE foos (
      id bigint PRIMARY KEY,
      secret boolean NOT NULL DEFAULT false
    );
  up: |
    ALTER TABLE "foos" ADD COLUMN "secret" boolean NOT NULL DEFAULT false;
    DROP VIEW "foos_view";
    CREATE VIEW "foos_view" AS select id, secret from foos where secret = false;
  down: |
    DROP VIEW "foos_view";
    CREATE VIEW "foos_view" AS select 1 as dummy;
    ALTER TABLE "foos" DROP COLUMN "secret";
CreateMaterializedView:
  current: |
    CREATE TABLE users (
      id BIGINT PRIMARY KEY,
      name character varying(100)
    );
    CREATE TABLE posts (
      id BIGINT PRIMARY KEY,
      name character varying(100),
      user_id BIGINT,
      is_deleted boolean
    );
  desired: |
    CREATE TABLE users (
      id BIGINT PRIMARY KEY,
      name character varying(100)
    );
    CREATE TABLE posts (
      id BIGINT PRIMARY KEY,
      name character varying(100),
      user_id BIGINT,
      is_deleted boolean
    );
    CREATE MATERIALIZED VIEW view_user_posts AS
      SELECT p.id FROM (posts as p JOIN users as u ON ((p.user_id = u.id)));
  up: |
    CREATE MATERIALIZED VIEW view_user_posts AS
      SELECT p.id FROM (posts as p JOIN users as u ON ((p.user_id = u.id)));
  down: |
    DROP MATERIALIZED VIEW "view_user_posts";
DropMaterializedView:
  current: |
    CREATE TABLE points (id bigint);
    CREATE MATERIALIZED VIEW IF NOT EXISTS points_view AS
      SELECT id FROM points;
  desired: |
    CREATE TABLE points (id bigint);
  up: |
    DROP MATERIALIZED VIEW "points_view";
  down: |
    CREATE MATERIALIZED VIEW IF NOT EXISTS points_view AS
      SELECT id FROM points;
MaterializedViewIndex:
  desired: |
    CREATE TABLE IF NOT EXISTS points (
        id          BIGINT        PRIMARY KEY,
        tenant_id   BIGINT        NOT NULL,
        user_id     VARCHAR(100)  NOT NULL,
        point_type  SMALLINT      NOT NULL,
        point_value SMALLINT      NOT NULL,
        created_at  TIMESTAMP     NOT NULL,
        updated_at  TIMESTAMP     NOT NULL
    );
    CREATE INDEX points_idx ON points (tenant_id, user_id, point_type);
    CREATE MATERIALIZED VIEW IF NOT EXISTS points_view AS
        SELECT * FROM points
        WHERE id IN (SELECT MAX(id) AS id
            FROM points
            GROUP BY point_type, user_id);
    CREATE INDEX points_view_idx ON points_view (tenant_id);
  up: |
    CREATE TABLE IF NOT EXISTS points (
        id          BIGINT        PRIMARY KEY,
        tenant_id   BIGINT        NOT NULL,
        user_id     VARCHAR(100)  NOT NULL,
        point_type  SMALLINT      NOT NULL,
        point_value SMALLINT      NOT NULL,
        created_at  TIMESTAMP     NOT NULL,
        updated_at  TIMESTAMP     NOT NULL
    );
    CREATE MATERIALIZED VIEW IF NOT EXISTS points_view AS
        SELECT * FROM points
        WHERE id IN (SELECT MAX(id) AS id
            FROM points
            GROUP BY point_type, user_id);
    CREATE INDEX points_idx ON points (tenant_id, user_id, point_type);
    CREATE INDEX points_view_idx ON points_view (tenant_id);
  down: |
    DROP MATERIALIZED VIEW "points_view";
    DROP TABLE "points";
ViewWithCTE:
  desired: |
    CREATE TABLE users (
      id bigint PRIMARY KEY,
      active boolean NOT NULL
    );
    CREATE VIEW active_users AS
    WITH recent_users AS (
      SELECT id FROM users WHERE active = true
    )
    SELECT id FROM recent_users;
MaterializedViewWithCTE:
  desired: |
    CREATE TABLE users (
      id bigint PRIMARY KEY,
      active boolean NOT NULL
    );
    CREATE MATERIALIZED VIEW active_users AS
    WITH recent_users AS (
      SELECT id FROM users WHERE active = true
    )
    SELECT * FROM recent_users;
MaterializedViewWithMultipleCTEs:
  desired: |
    CREATE TABLE sessions (
      user_id text NOT NULL,
      duration double precision NOT NULL,
      started_at timestamp NOT NULL
    );
    CREATE MATERIALIZED VIEW user_stats AS
    WITH active_users AS (
      SELECT DISTINCT user_id FROM sessions WHERE duration > 0
    ),
    user_counts AS (
      SELECT user_id, COUNT(*) as session_count FROM sessions GROUP BY user_id
    )
    SELECT au.user_id, uc.session_count
    FROM active_users au
    JOIN user_counts uc ON au.user_id = uc.user_id;
CreateViewWithUnion:
  desired: |
    CREATE VIEW test_view AS SELECT 1 AS id UNION SELECT 2 AS id;
CreateViewWithUnionAll:
  desired: |
    CREATE VIEW test_view AS SELECT 1 AS id UNION ALL SELECT 2 AS id;
CreateViewWithIntersect:
  desired: |
    CREATE VIEW test_view AS SELECT 1 AS id INTERSECT SELECT 2 AS id;
CreateViewWithExcept:
  desired: |
    CREATE VIEW test_view AS SELECT 1 AS id EXCEPT SELECT 2 AS id;
CreateMaterializedViewWithUnion:
  desired: |
    CREATE MATERIALIZED VIEW test_view AS SELECT 1 AS id UNION SELECT 2 AS id;
CreateMaterializedViewWithUnionAll:
  desired: |
    CREATE MATERIALIZED VIEW test_view AS SELECT 1 AS id UNION ALL SELECT 2 AS id;
CreateMaterializedViewWithUnionAllMultiple:
  desired: |
    CREATE MATERIALIZED VIEW test_view AS
    SELECT 1 AS id, 'a' AS name
    UNION ALL
    SELECT 2 AS id, 'b' AS name
    UNION ALL
    SELECT 3 AS id, 'c' AS name;
ViewWithDateFunction:
  desired: |
    CREATE TABLE events (
      created_at timestamp
    );
    CREATE VIEW event_dates AS
      SELECT date(created_at) AS event_date
      FROM events;
MaterializedViewWithDateFunction:
  desired: |
    CREATE TABLE activities (
      occurred_at timestamp
    );
    CREATE MATERIALIZED VIEW activity_dates AS
      SELECT date(occurred_at) AS activity_date
      FROM activities;
CreateViewCast:
  current: |
    CREATE TABLE "hoge" (
      "amount" text
    );
    CREATE VIEW hoge_view AS SELECT (hoge.amount)::numeric(10,2) AS amount_num FROM hoge;
  desired: |
    create table hoge (
      amount text
    );

    create view hoge_view as
    select
      amount::numeric(10,2) as amount_num
    from hoge;
  up: ''
  down: ""
ReplaceViewWithChangeCondition:
  current: |
    CREATE TABLE hoge (
      foo text,
      bar text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE hoge (
      foo text,
      bar text
    );

    CREATE VIEW v AS
      SELECT
        foo,
        bar
      FROM hoge
        WHERE bar = 'baz';
  up: |
    CREATE OR REPLACE VIEW "v" AS select foo, bar from hoge where bar = 'baz';
  down: |
    CREATE OR REPLACE VIEW "v" AS select foo, bar from hoge;
ReplaceViewWithAddColumnToTail:
  current: |
    CREATE TABLE "hoge" (
      "foo" text,
      "bar" text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE "hoge" (
      "foo" text,
      "bar" text
    );

    CREATE VIEW v AS
    SELECT
      foo,
      bar,
      'x' as added
     FROM hoge;
  up: |
    CREATE OR REPLACE VIEW "v" AS select foo, bar, 'x' as added from hoge;
  down: |
    DROP VIEW "v";
    CREATE VIEW "v" AS select foo, bar from hoge;
ReplaceViewWithAddColumnToMiddle:
  current: |
    CREATE TABLE "hoge" (
      "foo" text,
      "bar" text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE "hoge" (
      "foo" text,
      "bar" text
    );

    CREATE VIEW v AS
    SELECT
      foo,
      'x' as added,
      bar
     FROM hoge;
  up: |
    DROP VIEW "v";
    CREATE VIEW "v" AS select foo, 'x' as added, bar from hoge;
  down: |
    DROP VIEW "v";
    CREATE VIEW "v" AS select foo, bar from hoge;
ReplaceViewWithDropColumn:
  current: |
    CREATE TABLE "hoge" (
      "foo" text,
      "bar" text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE "hoge" (
      "foo" text,
      "bar" text
    );

    CREATE VIEW v AS
    SELECT foo FROM hoge;
  up: |
    DROP VIEW "v";
    CREATE VIEW "v" AS select foo from hoge;
  down: |
    CREATE OR REPLACE VIEW "v" AS select foo, bar from hoge;
ReplaceViewWithChangeColumn:
  current: |
    CREATE TABLE "hoge" (
      "foo" text,
      "bar" text
    );
    CREATE VIEW v AS
    SELECT
      foo,
      bar
    FROM hoge;
  desired: |
    CREATE TABLE "hoge" (
      "foo" text,
      "bar" text
    );

    CREATE VIEW v AS
    SELECT
      foo,
      'x' as changed
    FROM hoge;
  up: |
    DROP VIEW "v";
    CREATE VIEW "v" AS select foo, 'x' as changed from hoge;
  down: |
    DROP VIEW "v";
    CREATE VIEW "v" AS select foo, bar from hoge;
CreateViewWithCastCase:
  desired: |
    create table hoge (amount text);
    create view hoge_view as
    select
      '1'::numeric as n,
      ''::text as t,
      2::bigint as i,
      amount::numeric(10,2) as amount_num
    from hoge;
CreateViewWithCaseWhen:
  desired: |
    create table hoge (
      amount  text,
      hoge_type text,
      payload jsonb
    );
    create view hoge_view as
    select
      -- pattern 1
      amount::numeric(10,2) as amount_num1,
      -- pattern 2
      (
        jsonb_extract_path_text(payload, 'amount')
      )::numeric(10,2) as amount_num2,
      -- pattern 3
      (
        case hoge_type
          when 'hoge' then jsonb_extract_path_text(payload, 'hoge', 'amount')
        end
      )::numeric(10,2) as amount_num3,
      -- pattern 4
      (
        to_timestamp(
          jsonb_extract_path_text(payload, 'created')::bigint
        )
      ) as created,
      -- pattern 5
      (
        cast(
          to_timestamp(
            jsonb_extract_path_text(payload, 'created')::bigint
          ) as date
        )
      ) as created_date
    from hoge;
CreateViewWithoutFrom:
  desired: |
    create view v as select 10 as n;
ViewWithNullableColumn:
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY,
      name TEXT NULL,
      deleted BOOLEAN NOT NULL
    );
    CREATE VIEW active_users AS
    SELECT id, name FROM users WHERE NOT deleted;
ViewWithDistinct:
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE taggings (
      user_id INT NOT NULL REFERENCES users(id),
      tag TEXT NOT NULL
    );
    CREATE VIEW tags AS
    SELECT DISTINCT tag FROM taggings;
ViewWithGroupByAndHaving:
  desired: |
    CREATE TABLE users (
      id INT PRIMARY KEY
    );
    CREATE TABLE taggings (
      user_id INT NOT NULL REFERENCES users(id),
      tag TEXT NOT NULL
    );
    CREATE VIEW tag_counts AS
    SELECT tag, COUNT(*) AS count
    FROM taggings GROUP BY tag HAVING COUNT(*) > 1;
ExtractInMaterializedView:
  desired: |
    CREATE TABLE events (
      event_id bigint,
      event_timestamp timestamp
    );
    CREATE MATERIALIZED VIEW event_stats AS
      SELECT
        EXTRACT(year FROM event_timestamp) AS event_year,
        EXTRACT(month FROM event_timestamp) AS event_month,
        COUNT(*) AS event_count
      FROM events
      GROUP BY event_year, event_month;
ExtractBasicFields:
  desired: |
    CREATE TABLE events (
      id bigint,
      created_at timestamp
    );
    CREATE VIEW extract_view AS
      SELECT
        EXTRACT(year FROM created_at) AS year_value,
        EXTRACT(month FROM created_at) AS month_value,
        EXTRACT(day FROM created_at) AS day_value,
        EXTRACT(hour FROM created_at) AS hour_value,
        EXTRACT(minute FROM created_at) AS minute_value,
        EXTRACT(second FROM created_at) AS second_value,
        EXTRACT(epoch FROM created_at) AS epoch_value,
        EXTRACT(dow FROM created_at) AS dow_value,
        EXTRACT(doy FROM created_at) AS doy_value,
        EXTRACT(week FROM created_at) AS week_value,
        EXTRACT(quarter FROM created_at) AS quarter_value
      FROM events;
ExtractWithAge:
  desired: |
    CREATE TABLE user_info (
      user_id varchar,
      birthdate timestamp with time zone
    );
    CREATE VIEW age_view AS
      SELECT
        user_id,
        EXTRACT(year FROM age(birthdate)) AS age_years,
        EXTRACT(month FROM age(birthdate)) AS age_months
      FROM user_info;
CastBpchar:
  desired: |
    CREATE TABLE dummy_table (
      "col" character(30)
    );
    CREATE VIEW dummy_view AS
      SELECT dummy_table.col
      FROM dummy_table
      WHERE (dummy_table.col <> 'dummy value'::bpchar);
ViewWithAnyArray:
  desired: |
    CREATE VIEW any_array AS SELECT 1 WHERE 1 = ANY(ARRAY[1, 4, 5]);
MaterializedViewWithAnyArray:
  desired: |
    CREATE MATERIALIZED VIEW any_array AS SELECT 1 WHERE 1 = ANY(ARRAY[1, 4, 5]);

ViewWithRecursiveCTE:
  desired: |
    CREATE VIEW test_view AS
    WITH RECURSIVE cte AS (
      SELECT 1 AS n
      UNION ALL
      SELECT cte_1.n + 1
      FROM cte cte_1
      WHERE cte_1.n < 10
    )
    SELECT cte.n
    FROM cte;

ViewWithRecursiveHierarchy:
  desired: |
    CREATE TABLE employees (
      employee_id int PRIMARY KEY,
      manager_id int
    );
    CREATE VIEW employee_hierarchy AS
    WITH RECURSIVE subordinates AS (
      SELECT e.employee_id, e.manager_id, 1 AS emp_level
      FROM employees e
      WHERE e.manager_id IS NULL
      UNION ALL
      SELECT e.employee_id, e.manager_id, s.emp_level + 1
      FROM employees e
      INNER JOIN subordinates s ON s.employee_id = e.manager_id
    )
    SELECT employee_id, manager_id, emp_level FROM subordinates;

MaterializedViewWithRecursiveCTE:
  desired: |
    CREATE MATERIALIZED VIEW numbers AS
    WITH RECURSIVE cte AS (
      SELECT 1 AS n
      UNION ALL
      SELECT cte_1.n + 1
      FROM cte cte_1
      WHERE cte_1.n < 100
    )
    SELECT cte.n
    FROM cte;

ViewWithMultipleCTEsAndPostgreSQLFunctions:
  desired: |
    CREATE TABLE products (
      id bigint PRIMARY KEY,
      release_year int NOT NULL,
      release_month int NOT NULL
    );
    CREATE TABLE events (
      id bigint PRIMARY KEY,
      event_date date NOT NULL
    );
    CREATE TABLE product_events (
      event_id bigint NOT NULL,
      product_id bigint NOT NULL,
      PRIMARY KEY (event_id, product_id)
    );
    CREATE VIEW v_product_summary AS
    WITH
    event_counts AS (
      SELECT
        p.id AS product_id,
        e.id AS event_id,
        count(DISTINCT pe.event_id) AS count_until_event
      FROM products p
      CROSS JOIN events e
      LEFT JOIN product_events pe ON p.id = pe.product_id
      GROUP BY p.id, e.id
    ),
    release_dates AS (
      SELECT
        p.id AS product_id,
        e.id AS event_id,
        make_date(p.release_year, p.release_month, 1) AS release_date
      FROM products p
      CROSS JOIN events e
    )
    SELECT
      rd.product_id,
      rd.event_id,
      format('%s-%s', rd.release_date, ec.count_until_event) AS summary
    FROM release_dates rd
    LEFT JOIN event_counts ec ON rd.product_id = ec.product_id;

# View with WINDOW function (OVER clause)
ViewWithWindowFunction:
  legacy_ignore_quotes: false
  desired: |
    CREATE TABLE sales (id integer, amount numeric, sale_date date);
    CREATE VIEW sales_with_running_total AS
    SELECT id, amount, sale_date,
           SUM(amount) OVER (ORDER BY sale_date) AS running_total
    FROM sales;

# View with WINDOW function and PARTITION BY
ViewWithWindowPartition:
  legacy_ignore_quotes: false
  desired: |
    CREATE TABLE sales (id integer, category text, amount numeric, sale_date date);
    CREATE VIEW category_running_totals AS
    SELECT id, category, amount, sale_date,
           SUM(amount) OVER (PARTITION BY category ORDER BY sale_date) AS running_total
    FROM sales;

ViewWithNestedCaseAndValueAlias:
  legacy_ignore_quotes: false
  desired: |
    CREATE VIEW nested_case AS
    SELECT CASE
      WHEN 1 > 0 THEN 3
      ELSE CASE 4 + 1
        WHEN 1 THEN 1
        ELSE NULL
      END
    END AS value;

ViewWithColNameKeywordAliases:
  legacy_ignore_quotes: false
  desired: |
    CREATE TABLE test_data (id integer);
    CREATE VIEW keyword_aliases AS
    SELECT
      1 AS value,
      2 AS key,
      3 AS date,
      4 AS time,
      5 AS timestamp
    FROM test_data;

# View with JSON -> and ->> operators
ViewWithJsonOperators:
  legacy_ignore_quotes: false
  desired: |
    CREATE TABLE json_data (id integer, data jsonb);
    CREATE VIEW json_view AS
    SELECT id, data -> 'name' AS name, data ->> 'email' AS email
    FROM json_data;

ViewWithDistinctOn:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE carrier (carrier text);
  desired: |
    CREATE TABLE carrier (carrier text);
    CREATE VIEW carrier_current AS
    SELECT DISTINCT ON (c.carrier) c.carrier
    FROM carrier c;
  up: |
    CREATE VIEW carrier_current AS
    SELECT DISTINCT ON (c.carrier) c.carrier
    FROM carrier c;
  down: |
    DROP VIEW carrier_current;

ViewWithDistinctOnMultipleColumns:
  legacy_ignore_quotes: false
  current: |
    CREATE TABLE orders (customer_id int, order_date date, amount int);
  desired: |
    CREATE TABLE orders (customer_id int, order_date date, amount int);
    CREATE VIEW latest_orders AS
    SELECT DISTINCT ON (customer_id, order_date) customer_id, order_date, amount
    FROM orders;
  up: |
    CREATE VIEW latest_orders AS
    SELECT DISTINCT ON (customer_id, order_date) customer_id, order_date, amount
    FROM orders;
  down: |
    DROP VIEW latest_orders;
