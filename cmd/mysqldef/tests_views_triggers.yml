# yaml-language-server: $schema=../../testutil/testcase.schema.json

MysqlSecurityTypeView:
  current: |
    CREATE TABLE `users` (
      `id` bigint(20) NOT NULL,
      `name` varchar(50) NOT NULL
    );
    CREATE TABLE `posts` (
      `id` bigint(20) NOT NULL,
      `user_id` bigint(20) NOT NULL,
      is_deleted tinyint(1)
    );
    CREATE SQL SECURITY DEFINER VIEW `foo` AS select u.id as id, p.id as post_id, 'xxx' as name from (mysqldef_test.users as u join mysqldef_test.posts as p on ((u.id = p.user_id)));
  desired: |
    CREATE TABLE `users` (
      `id` bigint(20) NOT NULL,
      `name` varchar(50) NOT NULL
    );
    CREATE TABLE `posts` (
      `id` bigint(20) NOT NULL,
      `user_id` bigint(20) NOT NULL,
      is_deleted tinyint(1)
    );
    CREATE SQL SECURITY INVOKER VIEW `foo` AS select u.id as id, p.id as post_id, 'xxx' as name from (mysqldef_test.users as u join mysqldef_test.posts as p on ((u.id = p.user_id)));
  up: |
    CREATE OR REPLACE SQL SECURITY INVOKER VIEW `foo` AS select u.id as id, p.id as post_id, 'xxx' as name from (mysqldef_test.users as u join mysqldef_test.posts as p on ((u.id = p.user_id)));
  down: |
    CREATE OR REPLACE SQL SECURITY DEFINER VIEW `foo` AS select u.id as id, p.id as post_id, 'xxx' as name from (mysqldef_test.users as u join mysqldef_test.posts as p on ((u.id = p.user_id)));
CreateTriggerWithComplexStatements:
  flavor: "!tidb"
  desired: |
    CREATE TABLE test_trigger (
      id int(10) unsigned NOT NULL AUTO_INCREMENT,
      name varchar(255) COLLATE utf8mb4_bin NOT NULL,
      created_at datetime NOT NULL,
      updated_at datetime NOT NULL,
      PRIMARY KEY (id)
    );
    CREATE TRIGGER `test_trigger_BEFORE_UPDATE` before update ON `test_trigger` FOR EACH ROW begin
    if (COALESCE(OLD.name, 0) != COALESCE(NEW.name, 0)) then
    if OLD.name is not null then
    delete from test_trigger where name = OLD.name;
    end if;
    if NEW.name is not null and NEW.id is not null then
    delete from test_trigger where name = OLD.name;
    end if;
    else
    delete from test_trigger where name = OLD.name;
    end if;
    set NEW.updated_at = now();
    end;
  up: |
    CREATE TABLE test_trigger (
      id int(10) unsigned NOT NULL AUTO_INCREMENT,
      name varchar(255) COLLATE utf8mb4_bin NOT NULL,
      created_at datetime NOT NULL,
      updated_at datetime NOT NULL,
      PRIMARY KEY (id)
    );
    CREATE TRIGGER `test_trigger_BEFORE_UPDATE` before update ON `test_trigger` FOR EACH ROW begin
    if (COALESCE(OLD.name, 0) != COALESCE(NEW.name, 0)) then
    if OLD.name is not null then
    delete from test_trigger where name = OLD.name;
    end if;
    if NEW.name is not null and NEW.id is not null then
    delete from test_trigger where name = OLD.name;
    end if;
    else
    delete from test_trigger where name = OLD.name;
    end if;
    set NEW.updated_at = now();
    end;
  down: |
    DROP TABLE `test_trigger`;
CreateTriggerWithMultipleStatements:
  flavor: "!tidb"
  desired: |
    CREATE TABLE test_trigger (
      id int(11) NOT NULL AUTO_INCREMENT,
      created_at datetime NOT NULL,
      updated_at datetime NOT NULL,
      modified_at datetime NOT NULL,
      PRIMARY KEY (id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    CREATE TRIGGER `test_trigger_BEFORE_INSERT` before insert ON `test_trigger` FOR EACH ROW begin
    set NEW.created_at = now();
    set NEW.updated_at = now();
    set NEW.modified_at = now();
    end;
  up: |
    CREATE TABLE test_trigger (
      id int(11) NOT NULL AUTO_INCREMENT,
      created_at datetime NOT NULL,
      updated_at datetime NOT NULL,
      modified_at datetime NOT NULL,
      PRIMARY KEY (id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    CREATE TRIGGER `test_trigger_BEFORE_INSERT` before insert ON `test_trigger` FOR EACH ROW begin
    set NEW.created_at = now();
    set NEW.updated_at = now();
    set NEW.modified_at = now();
    end;
  down: |
    DROP TABLE `test_trigger`;
View:
  desired: |
    CREATE TABLE users (
      id bigint(20) NOT NULL
    );
    CREATE TABLE posts (
      id bigint(20) NOT NULL,
      user_id bigint(20) NOT NULL,
      is_deleted tinyint(1)
    );
    CREATE VIEW foo AS select u.id as id, p.id as post_id from  (mysqldef_test.users as u join mysqldef_test.posts as p on ((u.id = p.user_id)));
  flavor: mysql  # MariaDB shows unexpected view changes in idempotency tests
ViewUpdate:
  current: |
    CREATE TABLE users (
      id bigint(20) NOT NULL
    );
    CREATE TABLE posts (
      id bigint(20) NOT NULL,
      user_id bigint(20) NOT NULL,
      is_deleted tinyint(1)
    );
    CREATE VIEW foo AS select u.id as id, p.id as post_id from  (mysqldef_test.users as u join mysqldef_test.posts as p on ((u.id = p.user_id)));
  desired: |
    CREATE TABLE users (
      id bigint(20) NOT NULL
    );
    CREATE TABLE posts (
      id bigint(20) NOT NULL,
      user_id bigint(20) NOT NULL,
      is_deleted tinyint(1)
    );
    CREATE VIEW foo AS select u.id as id, p.id as post_id from (mysqldef_test.users as u join mysqldef_test.posts as p on (((u.id = p.user_id) and (p.is_deleted = 0))));
  up: |
    CREATE OR REPLACE VIEW `foo` AS select u.id as id, p.id as post_id from (mysqldef_test.users as u join mysqldef_test.posts as p on (((u.id = p.user_id) and (p.is_deleted = 0))));
  down: |
    CREATE OR REPLACE VIEW `foo` AS select u.id as id, p.id as post_id from (mysqldef_test.users as u join mysqldef_test.posts as p on ((u.id = p.user_id)));
  flavor: mysql  # MariaDB handles view formatting differently than MySQL
ViewDropsWhenEmptyDesired:
  current: |
    CREATE TABLE users (
      id bigint(20) NOT NULL
    );
    CREATE TABLE posts (
      id bigint(20) NOT NULL,
      user_id bigint(20) NOT NULL,
      is_deleted tinyint(1)
    );
    CREATE VIEW foo AS select u.id as id, p.id as post_id from (mysqldef_test.users as u join mysqldef_test.posts as p on (((u.id = p.user_id) and (p.is_deleted = 0))));
  desired: |
  up: |
    DROP VIEW `foo`;
    DROP TABLE `posts`;
    DROP TABLE `users`;
  down: |
    CREATE TABLE users (
      id bigint(20) NOT NULL
    );
    CREATE TABLE posts (
      id bigint(20) NOT NULL,
      user_id bigint(20) NOT NULL,
      is_deleted tinyint(1)
    );
    CREATE VIEW foo AS select u.id as id, p.id as post_id from (mysqldef_test.users as u join mysqldef_test.posts as p on (((u.id = p.user_id) and (p.is_deleted = 0))));
  flavor: mysql  # MariaDB shows unexpected view changes in idempotency tests
TriggerInsert:
  flavor: "!tidb"
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
    CREATE TABLE logs (
      id bigint NOT NULL,
      log varchar(20),
      dt datetime
    );
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(log, dt) values ('insert', now());
TriggerInsertUpdate:
  flavor: "!tidb"
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
    CREATE TABLE logs (
      id bigint NOT NULL,
      log varchar(20),
      dt datetime
    );
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(log, dt) values ('insert', now());
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
    CREATE TABLE logs (
      id bigint NOT NULL,
      log varchar(20),
      dt datetime
    );
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(log, dt) values ('insert_users', now());
  up: |
    DROP TRIGGER `insert_log`;
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(log, dt) values ('insert_users', now());
  down: |
    DROP TRIGGER `insert_log`;
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(log, dt) values ('insert', now());
TriggerInsertBeforeUpdate:
  flavor: "!tidb"
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
    CREATE TABLE logs (
      id bigint NOT NULL,
      log varchar(20),
      dt datetime
    );
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(log, dt) values ('insert_users', now());
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
    CREATE TABLE logs (
      id bigint NOT NULL,
      log varchar(20),
      dt datetime
    );
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(log, dt) values ('insert_users', now());
    CREATE TRIGGER `insert_log_before_update` before update ON `users` FOR EACH ROW insert into log(log, dt) values ('insert', now());
  up: |
    CREATE TRIGGER `insert_log_before_update` before update ON `users` FOR EACH ROW insert into log(log, dt) values ('insert', now());
  down: ""
TriggerInsertBeforeUpdateChange:
  flavor: "!tidb"
  current: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
    CREATE TABLE logs (
      id bigint NOT NULL,
      log varchar(20),
      dt datetime
    );
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(log, dt) values ('insert_users', now());
    CREATE TRIGGER `insert_log_before_update` before update ON `users` FOR EACH ROW insert into log(log, dt) values ('insert', now());
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
    CREATE TABLE logs (
      id bigint NOT NULL,
      log varchar(20),
      dt datetime
    );
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(log, dt) values ('insert_users', now());
    CREATE TRIGGER `insert_log_before_update` before update ON `users` FOR EACH ROW insert into log(log, dt) values ('insert_users', now());
  up: |
    DROP TRIGGER `insert_log_before_update`;
    CREATE TRIGGER `insert_log_before_update` before update ON `users` FOR EACH ROW insert into log(log, dt) values ('insert_users', now());
  down: |
    DROP TRIGGER `insert_log_before_update`;
    CREATE TRIGGER `insert_log_before_update` before update ON `users` FOR EACH ROW insert into log(log, dt) values ('insert', now());
TriggerSetNew:
  flavor: "!tidb"
  desired: |
    CREATE TABLE users (
      id int unsigned NOT NULL AUTO_INCREMENT,
      name varchar(255) NOT NULL,
      deleted_at timestamp NULL DEFAULT NULL,
      logical_uniqueness tinyint(1) DEFAULT '1',
      PRIMARY KEY (id)
    );
    CREATE TRIGGER `set_logical_uniqueness_on_users` before update ON `users` FOR EACH ROW set NEW.logical_uniqueness = 1;
TriggerSetNewComplex:
  flavor: "!tidb"
  current: |
    CREATE TABLE users (
      id int unsigned NOT NULL AUTO_INCREMENT,
      name varchar(255) NOT NULL,
      deleted_at timestamp NULL DEFAULT NULL,
      logical_uniqueness tinyint(1) DEFAULT '1',
      PRIMARY KEY (id)
    );
    CREATE TRIGGER `set_logical_uniqueness_on_users` before update ON `users` FOR EACH ROW set NEW.logical_uniqueness = 1;
  desired: |
    CREATE TABLE users (
      id int unsigned NOT NULL AUTO_INCREMENT,
      name varchar(255) NOT NULL,
      deleted_at timestamp NULL DEFAULT NULL,
      logical_uniqueness tinyint(1) DEFAULT '1',
      PRIMARY KEY (id)
    );
    CREATE TRIGGER `set_logical_uniqueness_on_users` before update ON `users` FOR EACH ROW set NEW.logical_uniqueness = 1;
    CREATE TRIGGER `set_logical_uniqueness_on_users2` before update ON `users` FOR EACH ROW set NEW.logical_uniqueness = case when NEW.deleted_at is null then 1 when NEW.deleted_at is not null then null end;
  up: |
    CREATE TRIGGER `set_logical_uniqueness_on_users2` before update ON `users` FOR EACH ROW set NEW.logical_uniqueness = case when NEW.deleted_at is null then 1 when NEW.deleted_at is not null then null end;
  down: ""
TriggerBeginEnd:
  flavor: "!tidb"
  desired: |
    CREATE TABLE test_trigger (
      id int(11) NOT NULL AUTO_INCREMENT,
      PRIMARY KEY (id)
    );
    CREATE TRIGGER `BEFORE_UPDATE_test_trigger` before insert ON `test_trigger` FOR EACH ROW begin
    set NEW.id = NEW.id + 10;
    end;
TriggerIf:
  flavor: "!tidb"
  desired: |
    CREATE TABLE test_trigger (
      id int(11) NOT NULL AUTO_INCREMENT,
      set_id int(11) NOT NULL,
      sort_order int(11) NOT NULL,
      PRIMARY KEY (id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    CREATE TRIGGER `test_trigger_BEFORE_INSERT` before insert ON `test_trigger` FOR EACH ROW begin
    if NEW.sort_order is null or NEW.sort_order = 0 then
    set NEW.sort_order = (select COALESCE(MAX(sort_order) + 1, 1) from test_trigger where set_id = NEW.set_id);
    end if;
    end;
TriggerUpdate:
  flavor: "!tidb"
  desired: |
    CREATE TABLE t1 (
      id int(11) NOT NULL AUTO_INCREMENT,
      t2_id int(11),
      PRIMARY KEY (id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    CREATE TABLE t2 (
      id int(11) NOT NULL AUTO_INCREMENT,
      PRIMARY KEY (id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    CREATE TRIGGER `t2_BEFORE_DELETE` before delete ON `t2` FOR EACH ROW update t1 set t2_id = null where t1.t2_id = OLD.id;
TriggerSelect:
  flavor: "!tidb"
  desired: |
    CREATE TABLE users (
      id int unsigned NOT NULL AUTO_INCREMENT,
      name varchar(255) NOT NULL,
      deleted_at timestamp NULL DEFAULT NULL,
      logical_uniqueness tinyint(1) DEFAULT '1',
      PRIMARY KEY (id)
    );
    CREATE TRIGGER `set_logical_uniqueness_on_users` before update ON `users` FOR EACH ROW set NEW.logical_uniqueness = (select 1 from dual);
TriggerUseReservedWordsAsColumn:
  flavor: "!tidb"
  desired: |
    CREATE TABLE test_trigger (
      id int(11) NOT NULL AUTO_INCREMENT,
      `status` int(4),
      `interval` int(4),
      PRIMARY KEY (id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    CREATE TRIGGER `test_trigger_BEFORE_INSERT` before insert ON `test_trigger` FOR EACH ROW begin
    set NEW.status = 0;
    set NEW.interval = 0;
    end;
TriggerSubtractionWithoutSpace:
  flavor: "!tidb"
  desired: |
    CREATE TABLE test_trigger (
      id int(11) NOT NULL AUTO_INCREMENT,
      `status` int(4),
      PRIMARY KEY (id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    CREATE TRIGGER `test_trigger_BEFORE_INSERT` before insert ON `test_trigger` FOR EACH ROW begin
    set NEW.status = 1+1-1;
    end;
  up: |
    CREATE TABLE test_trigger (
      id int(11) NOT NULL AUTO_INCREMENT,
      `status` int(4),
      PRIMARY KEY (id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    CREATE TRIGGER `test_trigger_BEFORE_INSERT` before insert ON `test_trigger` FOR EACH ROW begin
    set NEW.status = 1 + 1 - 1;
    end;
  down: |
    DROP TABLE `test_trigger`;
TriggerNonReservedWordInInsertList:
  flavor: "!tidb"
  desired: |
    CREATE TABLE users (
      id bigint NOT NULL,
      name text
    );
    CREATE TABLE logs (
      id bigint NOT NULL,
      `status` int,
      `off` int
    );
    CREATE TRIGGER `insert_log` after insert ON `users` FOR EACH ROW insert into log(status, off) values (0, 0);
TriggerWithDeclareContinueHandler:
  flavor: "!tidb"
  desired: |
    CREATE TABLE example_table (
      id int NOT NULL,
      col_a varchar(255),
      col_b varchar(255),
      created_at datetime,
      updated_at datetime
    );
    CREATE TABLE example_table_new (
      id int NOT NULL,
      col_a varchar(255),
      col_b varchar(255),
      created_at datetime,
      updated_at datetime
    );
    CREATE TRIGGER trg_insert_example
      AFTER INSERT ON example_table
    FOR EACH ROW
    BEGIN
      DECLARE CONTINUE HANDLER FOR 1146 BEGIN END;
      REPLACE INTO example_table_new (
        id, col_a, col_b, created_at, updated_at
      ) VALUES (
        NEW.id, NEW.col_a, NEW.col_b, NEW.created_at, NEW.updated_at
      );
    END;
  up: |
    CREATE TABLE example_table (
      id int NOT NULL,
      col_a varchar(255),
      col_b varchar(255),
      created_at datetime,
      updated_at datetime
    );
    CREATE TABLE example_table_new (
      id int NOT NULL,
      col_a varchar(255),
      col_b varchar(255),
      created_at datetime,
      updated_at datetime
    );
    CREATE TRIGGER `trg_insert_example` after insert ON `example_table` FOR EACH ROW begin
    declare
    continue handler for 1146
    begin
    end;
    replace into example_table_new(id, col_a, col_b, created_at, updated_at) values (NEW.id, NEW.col_a, NEW.col_b, NEW.created_at, NEW.updated_at);
    end;
  down: |
    DROP TABLE `example_table`;
    DROP TABLE `example_table_new`;
TriggerWithDeclareExitHandler:
  flavor: "!tidb"
  desired: |
    CREATE TABLE example_table (
      id int NOT NULL,
      name varchar(255)
    );
    CREATE TRIGGER trg_exit_handler
      BEFORE INSERT ON example_table
    FOR EACH ROW
    BEGIN
      DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN END;
      SET NEW.name = UPPER(NEW.name);
    END;
  up: |
    CREATE TABLE example_table (
      id int NOT NULL,
      name varchar(255)
    );
    CREATE TRIGGER `trg_exit_handler` before insert ON `example_table` FOR EACH ROW begin
    declare
    exit handler for sqlexception
    begin
    end;
    set NEW.name = UPPER(NEW.name);
    end;
  down: |
    DROP TABLE `example_table`;
TriggerWithDeclareHandlerSqlstate:
  flavor: "!tidb"
  desired: |
    CREATE TABLE example_table (
      id int NOT NULL,
      name varchar(255)
    );
    CREATE TRIGGER trg_sqlstate_handler
      BEFORE INSERT ON example_table
    FOR EACH ROW
    BEGIN
      DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x = 1;
      INSERT INTO example_table VALUES (NEW.id, NEW.name);
    END;
  up: |
    CREATE TABLE example_table (
      id int NOT NULL,
      name varchar(255)
    );
    CREATE TRIGGER `trg_sqlstate_handler` before insert ON `example_table` FOR EACH ROW begin
    declare
    continue handler for sqlstate '23000'
    set @x = 1;
    insert into example_table values (NEW.id, NEW.name);
    end;
  down: |
    DROP TABLE `example_table`;
TriggerWithDeclareHandlerMultipleStatements:
  flavor: "!tidb"
  desired: |
    CREATE TABLE example_table (
      id int NOT NULL,
      name varchar(255)
    );
    CREATE TABLE error_log (
      error_msg varchar(255)
    );
    CREATE TRIGGER trg_handler_complex
      AFTER INSERT ON example_table
    FOR EACH ROW
    BEGIN
      DECLARE CONTINUE HANDLER FOR 1146
      BEGIN
        INSERT INTO error_log VALUES ('Table not found');
        SET @error_count = @error_count + 1;
      END;
      INSERT INTO example_table VALUES (NEW.id, NEW.name);
    END;
  up: |
    CREATE TABLE example_table (
      id int NOT NULL,
      name varchar(255)
    );
    CREATE TABLE error_log (
      error_msg varchar(255)
    );
    CREATE TRIGGER `trg_handler_complex` after insert ON `example_table` FOR EACH ROW begin
    declare
    continue handler for 1146
    begin
    insert into error_log values ('Table not found');
    set @error_count = @error_count + 1;
    end;
    insert into example_table values (NEW.id, NEW.name);
    end;

  down: |
    DROP TABLE `error_log`;
    DROP TABLE `example_table`;