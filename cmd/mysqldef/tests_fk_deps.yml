# Test cases to reproduce issues mentioned in the Qiita article
# https://qiita.com/abe_masanori/items/7fd2a470e7eba2f255a4

# Issue 1: order of create tables with foreign key constraints
ForeignKeyDependenciesForCreateTables:
  apply_only: true
  desired: |
    CREATE TABLE `items` (
      `item_id` int NOT NULL,
      `item_name` varchar(100) DEFAULT NULL,
      PRIMARY KEY (`item_id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

    CREATE TABLE `users` (
      `user_id` int NOT NULL,
      `family_name` varchar(100) NOT NULL,
      `given_name` varchar(100) NOT NULL,
      `email_address` varchar(254) NOT NULL,
      PRIMARY KEY (`user_id`),
      UNIQUE KEY `uk_email_address` (`email_address`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

    CREATE TABLE `sales` (
      `sales_id` int NOT NULL,
      `user_id` int NOT NULL,
      `item_id` int NOT NULL,
      `sales_qty` int NOT NULL,
      `sales_amt` int NOT NULL,
      PRIMARY KEY (`sales_id`),
      KEY `fk_user_id` (`user_id`),
      KEY `fk_item_id` (`item_id`),
      CONSTRAINT `fk_item_id` FOREIGN KEY (`item_id`) REFERENCES `items` (`item_id`),
      CONSTRAINT `fk_user_id` FOREIGN KEY (`user_id`) REFERENCES `users` (`user_id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

# Issue 2: Complex primary key change with foreign key dependencies
# Changing primary key from single column to composite when foreign keys exist
# This test demonstrates the limitation when trying to change a primary key
# that is referenced by foreign keys
ForeignKeyDependenciesPrimaryKeyChange:
  current: |
    CREATE TABLE `items` (
      `item_id` int PRIMARY KEY,
      `supplier_id` int,
      `name` VARCHAR(100)
    );
    CREATE TABLE `item_prices` (
      `price_id` int PRIMARY KEY,
      `item_id` int,
      `price` DECIMAL(10,2),
      CONSTRAINT `prices_item_fk` FOREIGN KEY (`item_id`) REFERENCES `items` (`item_id`)
    );
  desired: |
    CREATE TABLE `items` (
      `item_id` int NOT NULL,
      `supplier_id` int NOT NULL,
      `name` VARCHAR(100),
      PRIMARY KEY (`supplier_id`, `item_id`)
    );
    CREATE TABLE `item_prices` (
      `price_id` int PRIMARY KEY,
      `item_id` int,
      `supplier_id` int,
      `price` DECIMAL(10,2),
      CONSTRAINT `prices_item_fk` FOREIGN KEY (`supplier_id`, `item_id`)
        REFERENCES `items` (`supplier_id`, `item_id`)
    );
  output: |
    ALTER TABLE `items` CHANGE COLUMN `supplier_id` `supplier_id` int NOT NULL;
    ALTER TABLE `item_prices` DROP FOREIGN KEY `prices_item_fk`;
    ALTER TABLE `item_prices` DROP INDEX `prices_item_fk`;
    ALTER TABLE `items` DROP PRIMARY KEY;
    ALTER TABLE `items` ADD PRIMARY KEY (`supplier_id`, `item_id`);
    ALTER TABLE `item_prices` ADD COLUMN `supplier_id` int AFTER `item_id`;
    ALTER TABLE `item_prices` ADD CONSTRAINT `prices_item_fk` FOREIGN KEY (`supplier_id`, `item_id`) REFERENCES `items` (`supplier_id`, `item_id`);

# Issue 3: Circular foreign key dependencies
ForeignKeyDependenciesCircular:
  current: |
    CREATE TABLE `departments` (
      `dept_id` int PRIMARY KEY,
      `name` VARCHAR(100)
    );
    CREATE TABLE `employees` (
      `emp_id` int PRIMARY KEY,
      `dept_id` int,
      `name` VARCHAR(100)
    );
  desired: |
    CREATE TABLE `departments` (
      `dept_id` int PRIMARY KEY,
      `name` VARCHAR(100),
      `manager_id` int
    );
    CREATE TABLE `employees` (
      `emp_id` int PRIMARY KEY,
      `dept_id` int,
      `name` VARCHAR(100),
      CONSTRAINT `emp_dept_fk` FOREIGN KEY (`dept_id`) REFERENCES `departments` (`dept_id`)
    );
    ALTER TABLE `departments` ADD CONSTRAINT `dept_manager_fk`
      FOREIGN KEY (`manager_id`) REFERENCES `employees` (`emp_id`);
  output: |
    ALTER TABLE `departments` ADD COLUMN `manager_id` int AFTER `name`;
    ALTER TABLE `employees` ADD CONSTRAINT `emp_dept_fk` FOREIGN KEY (`dept_id`) REFERENCES `departments` (`dept_id`);
    ALTER TABLE `departments` ADD CONSTRAINT `dept_manager_fk`
      FOREIGN KEY (`manager_id`) REFERENCES `employees` (`emp_id`);

# Issue 4: Add constraint after table creation (mentioned as limited support)
ForeignKeyDependenciesAddConstraintAfterCreation:
  current: |
    CREATE TABLE `orders` (
      `order_id` int PRIMARY KEY,
      `customer_id` int,
      `order_date` DATE
    );
    CREATE TABLE `customers` (
      `customer_id` int PRIMARY KEY,
      `name` VARCHAR(100)
    );
  desired: |
    CREATE TABLE `orders` (
      `order_id` int PRIMARY KEY,
      `customer_id` int,
      `order_date` DATE
    );
    CREATE TABLE `customers` (
      `customer_id` int PRIMARY KEY,
      `name` VARCHAR(100)
    );
    ALTER TABLE `orders` ADD CONSTRAINT `order_customer_fk`
      FOREIGN KEY (`customer_id`) REFERENCES `customers` (`customer_id`);
  output: |
    ALTER TABLE `orders` ADD CONSTRAINT `order_customer_fk`
      FOREIGN KEY (`customer_id`) REFERENCES `customers` (`customer_id`);

# Issue 5: Multiple foreign keys to same table being modified
ForeignKeyDependenciesMultipleToModifiedTable:
  current: |
    CREATE TABLE `users` (
      `user_id` int PRIMARY KEY,
      `username` VARCHAR(50)
    );
    CREATE TABLE `posts` (
      `post_id` int PRIMARY KEY,
      `author_id` int,
      `reviewer_id` int,
      CONSTRAINT `posts_author_fk` FOREIGN KEY (`author_id`) REFERENCES `users` (`user_id`),
      CONSTRAINT `posts_reviewer_fk` FOREIGN KEY (`reviewer_id`) REFERENCES `users` (`user_id`)
    );
  desired: |
    CREATE TABLE `users` (
      `user_id` int NOT NULL,
      `username` VARCHAR(50),
      `tenant_id` int NOT NULL,
      PRIMARY KEY (`tenant_id`, `user_id`)
    );
    CREATE TABLE `posts` (
      `post_id` int PRIMARY KEY,
      `author_id` int,
      `author_tenant_id` int,
      `reviewer_id` int,
      `reviewer_tenant_id` int,
      CONSTRAINT `posts_author_fk` FOREIGN KEY (`author_tenant_id`, `author_id`)
        REFERENCES `users` (`tenant_id`, `user_id`),
      CONSTRAINT `posts_reviewer_fk` FOREIGN KEY (`reviewer_tenant_id`, `reviewer_id`)
        REFERENCES `users` (`tenant_id`, `user_id`)
    );
  output: |
    ALTER TABLE `users` ADD COLUMN `tenant_id` int NOT NULL AFTER `username`;
    ALTER TABLE `posts` DROP FOREIGN KEY `posts_author_fk`;
    ALTER TABLE `posts` DROP INDEX `posts_author_fk`;
    ALTER TABLE `posts` DROP FOREIGN KEY `posts_reviewer_fk`;
    ALTER TABLE `posts` DROP INDEX `posts_reviewer_fk`;
    ALTER TABLE `users` DROP PRIMARY KEY;
    ALTER TABLE `users` ADD PRIMARY KEY (`tenant_id`, `user_id`);
    ALTER TABLE `posts` ADD COLUMN `author_tenant_id` int AFTER `author_id`;
    ALTER TABLE `posts` ADD COLUMN `reviewer_tenant_id` int AFTER `reviewer_id`;
    ALTER TABLE `posts` ADD CONSTRAINT `posts_author_fk` FOREIGN KEY (`author_tenant_id`, `author_id`) REFERENCES `users` (`tenant_id`, `user_id`);
    ALTER TABLE `posts` ADD CONSTRAINT `posts_reviewer_fk` FOREIGN KEY (`reviewer_tenant_id`, `reviewer_id`) REFERENCES `users` (`tenant_id`, `user_id`);

ForeignKeyDependenciesMultipleWithIdempotency:
  apply_only: true
  desired: |
    create table users (
      user_id integer primary key,
      family_name varchar(100) not null,
      given_name varchar(100) not null,
      email_address varchar(254) not null
    );

    create unique index uk_email_address on users(email_address);

    create table items (
      supplier_id integer,
      item_id integer,
      item_name varchar(100),
      constraint pk_items primary key (supplier_id, item_id)
    );

    create table sales (
      sales_id integer primary key,
      user_id integer not null,
      supplier_id integer,
      item_id integer not null,
      sales_qty integer not null,
      sales_amt integer not null,
      constraint fk_user_id
        foreign key (user_id) references users(user_id),
      constraint fk_supplier_id_item_id
        foreign key (supplier_id, item_id) references items(supplier_id, item_id)
    );

ForeignKeyDependenciesMultipleDrops:
  apply_only: true
  current: |
    create table users (
      user_id integer primary key,
      family_name varchar(100) not null,
      given_name varchar(100) not null,
      email_address varchar(254) not null
    );

    create unique index uk_email_address on users(email_address);

    create table items (
      supplier_id integer,
      item_id integer,
      item_name varchar(100),
      constraint pk_items primary key (supplier_id, item_id)
    );

    create table sales (
      sales_id integer primary key,
      user_id integer not null,
      supplier_id integer,
      item_id integer not null,
      sales_qty integer not null,
      sales_amt integer not null,
      constraint fk_user_id
        foreign key (user_id) references users(user_id),
      constraint fk_supplier_id_item_id
        foreign key (supplier_id, item_id) references items(supplier_id, item_id)
    );
  desired: "" # all drops

# Test case: Primary key column rename with foreign key from table that will be dropped
# When changing a primary key column and a referencing table will be dropped,
# we should not try to recreate the foreign key constraint
ForeignKeyWithPrimaryKeyChangeAndDrop:
  current: |
    CREATE TABLE users (
      id integer PRIMARY KEY
    );
    CREATE TABLE taggings (
      user_id integer NOT NULL,
      tag text NOT NULL,
      CONSTRAINT taggings_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(id)
    );
  desired: |
    CREATE TABLE users (
      user_id integer PRIMARY KEY,
      name text
    );
  output: |
    ALTER TABLE `users` ADD COLUMN `user_id` integer NOT NULL FIRST;
    ALTER TABLE `users` ADD COLUMN `name` text AFTER `user_id`;
    ALTER TABLE `taggings` DROP FOREIGN KEY `taggings_user_id_fkey`;
    ALTER TABLE `taggings` DROP INDEX `taggings_user_id_fkey`;
    ALTER TABLE `users` DROP PRIMARY KEY;
    ALTER TABLE `users` ADD PRIMARY KEY (`user_id`);
    DROP TABLE `taggings`;
    ALTER TABLE `users` DROP COLUMN `id`;
